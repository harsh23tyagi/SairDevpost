{"ast":null,"code":"/*\n * Screen recording function using ffmpeg.\n * Defaults to using x11grab, but also supports other input formats.\n *\n * Copyright 2019, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n'use strict';\n\nconst fs = require('fs');\n\nconst util = require('util');\n\nconst _require = require('child_process'),\n      execFile = _require.execFile;\n\nconst execFilePromise = util.promisify(execFile);\n/**\n * Builds an URL with the given properties.\n *\n * @param {object} [properties] URL properties\n * @param {string} [properties.protocol=http] Server protocol\n * @param {string} [properties.username] Basic auth username\n * @param {string} [properties.password] Basic auth password\n * @param {string} [properties.hostname=localhost] Server hostname\n * @param {number} [properties.port] Server port\n * @param {string} [properties.pathname] URL path component\n * @param {string} [properties.search] URL query parameter\n * @returns {string} URL\n */\n\nfunction buildURL(properties = {}) {\n  const url = new URL('http://localhost');\n  const keys = ['protocol', 'username', 'password', 'hostname', 'port', 'pathname', 'search'];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = properties[key];\n    if (value) url[key] = value;\n  }\n\n  return url.href;\n}\n/**\n * Builds arguments for the ffmpeg call.\n *\n * @param {string} fileName Output file name\n * @param {object} [options] Screen recording options\n * @param {string} [options.loglevel] Log verbosity level\n * @param {string} [options.inputFormat] Input format\n * @param {string} [options.resolution] Display resolution (WIDTHxHEIGHT)\n * @param {number} [options.fps] Frames per second to record from input\n * @param {string} [options.videoCodec] Video codec\n * @param {string} [options.pixelFormat] Output pixel format\n * @param {string} [options.hostname=localhost] Server hostname\n * @param {string} [options.display] X11 server display\n * @param {string} [options.protocol=http] Server protocol\n * @param {string} [options.username] Basic auth username\n * @param {string} [options.password] Basic auth password\n * @param {number} [options.port] Server port\n * @param {string} [options.pathname] URL path component\n * @param {string} [options.search] URL query parameter\n * @returns {Array<string>} ffmpeg arguments list\n */\n\n\nfunction buildFFMPEGArgs(fileName, options = {}) {\n  const args = ['-y']; // Override existing files\n\n  if (options.loglevel) {\n    args.push('-loglevel', options.loglevel);\n  }\n\n  if (options.resolution) {\n    // Must match X11 display resolution when using x11grab:\n    args.push('-video_size', options.resolution);\n  }\n\n  if (options.fps) {\n    // Frames per second to record from input:\n    args.push('-r', String(options.fps));\n  }\n\n  if (options.inputFormat) {\n    args.push('-f', options.inputFormat);\n  }\n\n  args.push('-i', // Construct the input URL:\n  options.inputFormat === 'x11grab' ? \"\".concat(options.hostname || '', \":\").concat(options.display) : buildURL(options));\n\n  if (options.videoCodec) {\n    args.push('-vcodec', options.videoCodec);\n  }\n\n  if (options.pixelFormat) {\n    args.push('-pix_fmt', options.pixelFormat);\n  }\n\n  args.push(fileName);\n  return args;\n}\n/**\n * @typedef {object} Result\n * @property {string} stdout Screen recording standard output\n * @property {string} stderr Screen recording error output\n */\n\n/**\n * @typedef {object} Recording\n * @property {Promise<Result>} promise Promise for the active screen recording\n * @property {Function} stop Function to stop the screen recording\n */\n\n/**\n * @typedef {object} Options Screen recording options\n * @property {string} [loglevel=info] Log verbosity level\n * @property {string} [inputFormat=x11grab] Input format\n * @property {string} [resolution] Display resolution (WIDTHxHEIGHT)\n * @property {number} [fps=15] Frames per second to record from input\n * @property {string} [videoCodec] Video codec\n * @property {string} [pixelFormat=yuv420p] Output pixel format\n * @property {number} [rotate] Rotate metadata, set to 90 to rotate left by 90Â°\n * @property {string} [hostname=localhost] Server hostname\n * @property {string} [display=0] X11 server display\n * @property {string} [protocol=http] Server protocol\n * @property {string} [username] Basic auth username\n * @property {string} [password] Basic auth password\n * @property {number} [port=9000] Server port\n * @property {string} [pathname] URL path component\n * @property {string} [search] URL query parameter\n */\n\n/**\n * Starts a screen recording via ffmpeg x11grab.\n *\n * @param {string} fileName Output file name\n * @param {Options} [options] Screen recording options\n * @returns {Recording} Recording object\n */\n\n\nfunction recordScreen(fileName, options) {\n  const args = buildFFMPEGArgs(fileName, Object.assign({\n    inputFormat: 'x11grab',\n    fps: 15,\n    pixelFormat: 'yuv420p',\n    // QuickTime compatibility\n    display: '0',\n    port: 9000\n  }, options));\n  let recProcess;\n  /**\n   * Executes the recording process.\n   *\n   * @param {Function} resolve Success callback\n   * @param {Function} reject Failure callback\n   */\n\n  function recordingExecutor(resolve, reject) {\n    recProcess = execFile('ffmpeg', args, function (error, stdout, stderr) {\n      recProcess = null; // ffmpeg returns with status 255 when receiving SIGINT:\n      // @ts-ignore Error interface does not expose killed and code properties\n\n      if (error && !(error.killed && error.code === 255)) return reject(error);\n      return resolve({\n        stdout,\n        stderr\n      });\n    });\n  }\n  /**\n   * Stops the recording process.\n   */\n\n\n  function stop() {\n    if (recProcess) recProcess.kill('SIGINT');\n  }\n  /**\n   * Sets meta data on the recorded video.\n   *\n   * @param {Result} result Recording result object\n   * @returns {Promise<Result>} Resolves with a recording result object\n   */\n\n\n  function setMetadata(result) {\n    if (!options.rotate) return Promise.resolve(result); // Metadata cannot be set when encoding, as the FFmpeg MP4 muxer has a bug\n    // that prevents changing metadata: https://trac.ffmpeg.org/ticket/6370\n    // So we set the metadata in a separate command execution:\n\n    const tmpFileName = fileName.replace(/[^.]+$/, 'tmp.$&');\n    const args = ['-y', '-loglevel', 'error', '-i', fileName, '-codec', 'copy', '-map_metadata', '0', '-metadata:s:v', 'rotate=' + options.rotate, tmpFileName];\n    return execFilePromise('ffmpeg', args).then(function () {\n      fs.unlinkSync(fileName);\n      fs.renameSync(tmpFileName, fileName);\n      return result;\n    });\n  }\n\n  const promise = new Promise(recordingExecutor).then(setMetadata);\n  return {\n    promise,\n    stop\n  };\n}\n\nmodule.exports = recordScreen;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar Socket = require('./socket');\n\nvar Emitter = require('events').EventEmitter;\n\nvar parser = require('socket.io-parser');\n\nvar hasBin = require('has-binary2');\n\nvar debug = require('debug')('socket.io:namespace');\n/**\n * Module exports.\n */\n\n\nmodule.exports = exports = Namespace;\n/**\n * Blacklisted events.\n */\n\nexports.events = ['connect', // for symmetry with client\n'connection', 'newListener'];\n/**\n * Flags.\n */\n\nexports.flags = ['json', 'volatile', 'local'];\n/**\n * `EventEmitter#emit` reference.\n */\n\nvar emit = Emitter.prototype.emit;\n/**\n * Namespace constructor.\n *\n * @param {Server} server instance\n * @param {Socket} name\n * @api private\n */\n\nfunction Namespace(server, name) {\n  this.name = name;\n  this.server = server;\n  this.sockets = {};\n  this.connected = {};\n  this.fns = [];\n  this.ids = 0;\n  this.rooms = [];\n  this.flags = {};\n  this.initAdapter();\n}\n/**\n * Inherits from `EventEmitter`.\n */\n\n\nNamespace.prototype.__proto__ = Emitter.prototype;\n/**\n * Apply flags from `Socket`.\n */\n\nexports.flags.forEach(function (flag) {\n  Object.defineProperty(Namespace.prototype, flag, {\n    get: function () {\n      this.flags[flag] = true;\n      return this;\n    }\n  });\n});\n/**\n * Initializes the `Adapter` for this nsp.\n * Run upon changing adapter by `Server#adapter`\n * in addition to the constructor.\n *\n * @api private\n */\n\nNamespace.prototype.initAdapter = function () {\n  this.adapter = new (this.server.adapter())(this);\n};\n/**\n * Sets up namespace middleware.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.use = function (fn) {\n  if (this.server.eio && this.name === '/') {\n    debug('removing initial packet');\n    delete this.server.eio.initialPacket;\n  }\n\n  this.fns.push(fn);\n  return this;\n};\n/**\n * Executes the middleware for an incoming client.\n *\n * @param {Socket} socket that will get added\n * @param {Function} fn last fn call in the middleware\n * @api private\n */\n\n\nNamespace.prototype.run = function (socket, fn) {\n  var fns = this.fns.slice(0);\n  if (!fns.length) return fn(null);\n\n  function run(i) {\n    fns[i](socket, function (err) {\n      // upon error, short-circuit\n      if (err) return fn(err); // if no middleware left, summon callback\n\n      if (!fns[i + 1]) return fn(null); // go on to next\n\n      run(i + 1);\n    });\n  }\n\n  run(0);\n};\n/**\n * Targets a room when emitting.\n *\n * @param {String} name\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.to = Namespace.prototype.in = function (name) {\n  if (!~this.rooms.indexOf(name)) this.rooms.push(name);\n  return this;\n};\n/**\n * Adds a new client.\n *\n * @return {Socket}\n * @api private\n */\n\n\nNamespace.prototype.add = function (client, query, fn) {\n  debug('adding socket to nsp %s', this.name);\n  var socket = new Socket(this, client, query);\n  var self = this;\n  this.run(socket, function (err) {\n    process.nextTick(function () {\n      if ('open' == client.conn.readyState) {\n        if (err) return socket.error(err.data || err.message); // track socket\n\n        self.sockets[socket.id] = socket; // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n\n        socket.onconnect();\n        if (fn) fn(); // fire user-set events\n\n        self.emit('connect', socket);\n        self.emit('connection', socket);\n      } else {\n        debug('next called after client was closed - ignoring socket');\n      }\n    });\n  });\n  return socket;\n};\n/**\n * Removes a client. Called by each `Socket`.\n *\n * @api private\n */\n\n\nNamespace.prototype.remove = function (socket) {\n  if (this.sockets.hasOwnProperty(socket.id)) {\n    delete this.sockets[socket.id];\n  } else {\n    debug('ignoring remove for %s', socket.id);\n  }\n};\n/**\n * Emits to all clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.emit = function (ev) {\n  if (~exports.events.indexOf(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  } // set up packet object\n\n\n  var args = Array.prototype.slice.call(arguments);\n  var packet = {\n    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,\n    data: args\n  };\n\n  if ('function' == typeof args[args.length - 1]) {\n    throw new Error('Callbacks are not supported when broadcasting');\n  }\n\n  var rooms = this.rooms.slice(0);\n  var flags = Object.assign({}, this.flags); // reset flags\n\n  this.rooms = [];\n  this.flags = {};\n  this.adapter.broadcast(packet, {\n    rooms: rooms,\n    flags: flags\n  });\n  return this;\n};\n/**\n * Sends a `message` event to all clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.send = Namespace.prototype.write = function () {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n/**\n * Gets a list of clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.clients = function (fn) {\n  if (!this.adapter) {\n    throw new Error('No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?');\n  }\n\n  this.adapter.clients(this.rooms, fn); // reset rooms for scenario:\n  // .in('room').clients() (GH-1978)\n\n  this.rooms = [];\n  return this;\n};\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} compress if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\n\nNamespace.prototype.compress = function (compress) {\n  this.flags.compress = compress;\n  return this;\n};\n/**\n * Sets the binary flag\n *\n * @param {Boolean} Encode as if it has binary data if `true`, Encode as if it doesnt have binary data if `false`\n * @return {Socket} self\n * @api public\n */\n\n\nNamespace.prototype.binary = function (binary) {\n  this.flags.binary = binary;\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}
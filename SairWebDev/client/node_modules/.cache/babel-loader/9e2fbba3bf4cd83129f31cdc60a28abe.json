{"ast":null,"code":"/**\n    * @license\n    * Copyright 2019 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nimport * as tf from \"@tensorflow/tfjs-core\";\nimport { tidy, util, oneHot, scalar, range, Tensor, browser, pad3d, slice3d, div, sub } from \"@tensorflow/tfjs-core\";\nimport { loadGraphModel } from \"@tensorflow/tfjs-converter\";\n\nfunction __awaiter(e, t, r, a) {\n  return new (r || (r = Promise))(function (n, o) {\n    function i(e) {\n      try {\n        d(a.next(e));\n      } catch (e) {\n        o(e);\n      }\n    }\n\n    function s(e) {\n      try {\n        d(a.throw(e));\n      } catch (e) {\n        o(e);\n      }\n    }\n\n    function d(e) {\n      e.done ? n(e.value) : new r(function (t) {\n        t(e.value);\n      }).then(i, s);\n    }\n\n    d((a = a.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var r,\n      a,\n      n,\n      o,\n      i = {\n    label: 0,\n    sent: function () {\n      if (1 & n[0]) throw n[1];\n      return n[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return o = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n    return this;\n  }), o;\n\n  function s(o) {\n    return function (s) {\n      return function (o) {\n        if (r) throw new TypeError(\"Generator is already executing.\");\n\n        for (; i;) try {\n          if (r = 1, a && (n = 2 & o[0] ? a.return : o[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, o[1])).done) return n;\n\n          switch (a = 0, n && (o = [2 & o[0], n.value]), o[0]) {\n            case 0:\n            case 1:\n              n = o;\n              break;\n\n            case 4:\n              return i.label++, {\n                value: o[1],\n                done: !1\n              };\n\n            case 5:\n              i.label++, a = o[1], o = [0];\n              continue;\n\n            case 7:\n              o = i.ops.pop(), i.trys.pop();\n              continue;\n\n            default:\n              if (!(n = (n = i.trys).length > 0 && n[n.length - 1]) && (6 === o[0] || 2 === o[0])) {\n                i = 0;\n                continue;\n              }\n\n              if (3 === o[0] && (!n || o[1] > n[0] && o[1] < n[3])) {\n                i.label = o[1];\n                break;\n              }\n\n              if (6 === o[0] && i.label < n[1]) {\n                i.label = n[1], n = o;\n                break;\n              }\n\n              if (n && i.label < n[2]) {\n                i.label = n[2], i.ops.push(o);\n                break;\n              }\n\n              n[2] && i.ops.pop(), i.trys.pop();\n              continue;\n          }\n\n          o = t.call(e, i);\n        } catch (e) {\n          o = [6, e], a = 0;\n        } finally {\n          r = n = 0;\n        }\n\n        if (5 & o[0]) throw o[1];\n        return {\n          value: o[0] ? o[1] : void 0,\n          done: !0\n        };\n      }([o, s]);\n    };\n  }\n}\n\nvar mobileNet100Architecture = [[\"conv2d\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1]],\n    mobileNet75Architecture = [[\"conv2d\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1]],\n    mobileNet50Architecture = [[\"conv2d\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 2], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1], [\"separableConv\", 1]],\n    mobileNet25Architecture = mobileNet50Architecture,\n    VALID_OUTPUT_STRIDES = [8, 16, 32];\n\nfunction assertValidOutputStride(e) {\n  util.assert(\"number\" == typeof e, function () {\n    return \"outputStride is not a number\";\n  }), util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {\n    return \"outputStride of \" + e + \" is invalid. It must be either 8, 16, or 32\";\n  });\n}\n\nvar mobileNetArchitectures = {\n  100: mobileNet100Architecture,\n  75: mobileNet75Architecture,\n  50: mobileNet50Architecture,\n  25: mobileNet25Architecture\n};\n\nfunction toOutputStridedLayers(e, t) {\n  var r = 1,\n      a = 1;\n  return e.map(function (e, n) {\n    var o,\n        i,\n        s = e[0],\n        d = e[1];\n    return r === t ? (o = 1, i = a, a *= d) : (o = d, i = 1, r *= d), {\n      blockId: n,\n      convType: s,\n      stride: o,\n      rate: i,\n      outputStride: r\n    };\n  });\n}\n\nvar MobileNet = function () {\n  function e(e, t) {\n    this.PREPROCESS_DIVISOR = scalar(127.5), this.ONE = scalar(1), this.modelWeights = e, this.convolutionDefinitions = t;\n  }\n\n  return e.prototype.predict = function (e, t) {\n    var r = this,\n        a = div(e.toFloat(), this.PREPROCESS_DIVISOR),\n        n = sub(a, this.ONE);\n    return toOutputStridedLayers(this.convolutionDefinitions, t).reduce(function (e, t) {\n      var a = t.blockId,\n          n = t.stride,\n          o = t.convType,\n          i = t.rate;\n      if (\"conv2d\" === o) return r.conv(e, n, a);\n      if (\"separableConv\" === o) return r.separableConv(e, n, a, i);\n      throw Error(\"Unknown conv type of \" + o);\n    }, n);\n  }, e.prototype.convToOutput = function (e, t) {\n    return e.conv2d(this.weights(t), 1, \"same\").add(this.convBias(t, !1));\n  }, e.prototype.conv = function (e, t, r) {\n    var a = this.weights(\"Conv2d_\" + String(r));\n    return e.conv2d(a, t, \"same\").add(this.convBias(\"Conv2d_\" + String(r))).clipByValue(0, 6);\n  }, e.prototype.separableConv = function (e, t, r, a) {\n    void 0 === a && (a = 1);\n    var n = \"Conv2d_\" + String(r) + \"_depthwise\",\n        o = \"Conv2d_\" + String(r) + \"_pointwise\";\n    return e.depthwiseConv2D(this.depthwiseWeights(n), t, \"same\", \"NHWC\", a).add(this.depthwiseBias(n)).clipByValue(0, 6).conv2d(this.weights(o), [1, 1], \"same\").add(this.convBias(o)).clipByValue(0, 6);\n  }, e.prototype.weights = function (e) {\n    return this.modelWeights.weights(e);\n  }, e.prototype.convBias = function (e, t) {\n    return void 0 === t && (t = !0), this.modelWeights.convBias(e, t);\n  }, e.prototype.depthwiseBias = function (e) {\n    return this.modelWeights.depthwiseBias(e);\n  }, e.prototype.depthwiseWeights = function (e) {\n    return this.modelWeights.depthwiseWeights(e);\n  }, e.prototype.dispose = function () {\n    this.modelWeights.dispose();\n  }, e;\n}(),\n    BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/\",\n    checkpoints = {\n  1: {\n    url: BASE_URL + \"posenet_mobilenet_100_partmap/\",\n    architecture: mobileNetArchitectures[100]\n  },\n  .75: {\n    url: BASE_URL + \"posenet_mobilenet_075_partmap/\",\n    architecture: mobileNetArchitectures[75]\n  },\n  .5: {\n    url: BASE_URL + \"posenet_mobilenet_050_partmap/\",\n    architecture: mobileNetArchitectures[50]\n  },\n  .25: {\n    url: BASE_URL + \"posenet_mobilenet_025_partmap/\",\n    architecture: mobileNetArchitectures[25]\n  }\n};\n\nfunction toFlattenedOneHotPartMap(e) {\n  var t = e.shape[2],\n      r = e.argMax(2).reshape([-1]);\n  return oneHot(r, t);\n}\n\nfunction clipByMask2d(e, t) {\n  return e.mul(t);\n}\n\nfunction toMask(e, t) {\n  return tidy(function () {\n    return e.greater(scalar(t)).toInt();\n  });\n}\n\nfunction decodePartSegmentation(e, t) {\n  var r = t.shape,\n      a = r[0],\n      n = r[1],\n      o = r[2];\n  return tidy(function () {\n    var r = toFlattenedOneHotPartMap(t),\n        i = range(0, o, 1, \"int32\").expandDims(1);\n    return clipByMask2d(r.matMul(i).toInt().reshape([a, n]).add(scalar(1, \"int32\")), e).sub(scalar(1, \"int32\"));\n  });\n}\n\nvar ModelWeights = function () {\n  function e(e) {\n    this.graphModel = e;\n  }\n\n  return e.prototype.weights = function (e) {\n    return this.getVariable(\"MobilenetV1/\" + e + \"/weights\");\n  }, e.prototype.convBias = function (e, t) {\n    return void 0 === t && (t = !0), this.getVariable(\"MobilenetV1/\" + e + \"/Conv2D_bias\");\n  }, e.prototype.depthwiseBias = function (e) {\n    return this.getVariable(\"MobilenetV1/\" + e + \"/depthwise_bias\");\n  }, e.prototype.depthwiseWeights = function (e) {\n    return this.getVariable(\"MobilenetV1/\" + e + \"/depthwise_weights\");\n  }, e.prototype.getVariable = function (e) {\n    return this.graphModel.weights[\"\" + e][0];\n  }, e.prototype.dispose = function () {\n    this.graphModel.dispose();\n  }, e;\n}();\n\nfunction toInputTensor(e) {\n  return e instanceof Tensor ? e : browser.fromPixels(e);\n}\n\nfunction resizeAndPadTo(e, t, r) {\n  var a = t[0],\n      n = t[1];\n  void 0 === r && (r = !1);\n  var o,\n      i,\n      s,\n      d,\n      u,\n      l,\n      c = e.shape,\n      p = c[0],\n      h = c[1] / p;\n\n  if (h > n / a) {\n    o = n;\n    var f = a - (i = Math.ceil(o / h));\n    s = 0, d = 0, u = Math.floor(f / 2), l = a - (i + u);\n  } else {\n    i = a;\n    var v = n - (o = Math.ceil(a * h));\n    s = Math.floor(v / 2), d = n - (o + s), u = 0, l = 0;\n  }\n\n  return {\n    resizedAndPadded: tidy(function () {\n      var t;\n      return t = r ? e.reverse(1).resizeBilinear([i, o]) : e.resizeBilinear([i, o]), pad3d(t, [[u, l], [s, d], [0, 0]]);\n    }),\n    paddedBy: [[u, l], [s, d]]\n  };\n}\n\nfunction scaleAndCropToInputTensorShape(e, t, r, a) {\n  var n = t[0],\n      o = t[1],\n      i = r[0],\n      s = r[1],\n      d = a[0],\n      u = d[0],\n      l = d[1],\n      c = a[1],\n      p = c[0],\n      h = c[1];\n  return tidy(function () {\n    return removePaddingAndResizeBack(e.resizeBilinear([i, s], !0), [n, o], [[u, l], [p, h]]);\n  });\n}\n\nfunction removePaddingAndResizeBack(e, t, r) {\n  var a = t[0],\n      n = t[1],\n      o = r[0],\n      i = o[0],\n      s = o[1],\n      d = r[1],\n      u = d[0],\n      l = d[1],\n      c = e.shape,\n      p = c[0],\n      h = c[1],\n      f = p - (i + s),\n      v = h - (u + l);\n  return tidy(function () {\n    return slice3d(e, [i, u, 0], [f, v, e.shape[2]]).resizeBilinear([a, n], !0);\n  });\n}\n\nvar _this = void 0,\n    segmentationModelImageDimensions = [353, 257],\n    BodyPix = function () {\n  function e(e) {\n    this.mobileNet = e;\n  }\n\n  return e.prototype.predictForSegmentation = function (e, t) {\n    var r = this;\n    return void 0 === t && (t = 16), assertValidOutputStride(t), tidy(function () {\n      var a = r.mobileNet.predict(e, t);\n      return r.mobileNet.convToOutput(a, \"segment_2\").sigmoid();\n    });\n  }, e.prototype.predictForPartMap = function (e, t) {\n    var r = this;\n    return void 0 === t && (t = 16), assertValidOutputStride(t), tidy(function () {\n      var a = r.mobileNet.predict(e, t),\n          n = r.mobileNet.convToOutput(a, \"segment_2\"),\n          o = r.mobileNet.convToOutput(a, \"part_heatmap_2\");\n      return {\n        segmentScores: n.sigmoid(),\n        partHeatmapScores: o.sigmoid()\n      };\n    });\n  }, e.prototype.estimatePersonSegmentationActivation = function (e, t, r) {\n    var a = this;\n    return void 0 === t && (t = 16), void 0 === r && (r = .5), assertValidOutputStride(t), tidy(function () {\n      var n = toInputTensor(e),\n          o = resizeAndPadTo(n, segmentationModelImageDimensions),\n          i = o.resizedAndPadded,\n          s = o.paddedBy,\n          d = a.predictForSegmentation(i, t),\n          u = i.shape,\n          l = u[0],\n          c = u[1],\n          p = n.shape;\n      return toMask(scaleAndCropToInputTensorShape(d, [p[0], p[1]], [l, c], s).squeeze(), r);\n    });\n  }, e.prototype.estimatePersonSegmentation = function (e, t, r) {\n    return void 0 === t && (t = 16), void 0 === r && (r = .5), __awaiter(this, void 0, void 0, function () {\n      var a, n, o, i, s;\n      return __generator(this, function (d) {\n        switch (d.label) {\n          case 0:\n            return a = this.estimatePersonSegmentationActivation(e, t, r), n = a.shape, o = n[0], i = n[1], [4, a.data()];\n\n          case 1:\n            return s = d.sent(), a.dispose(), [2, {\n              height: o,\n              width: i,\n              data: s\n            }];\n        }\n      });\n    });\n  }, e.prototype.estimatePartSegmentationActivation = function (e, t, r) {\n    var a = this;\n    return void 0 === t && (t = 16), void 0 === r && (r = .5), assertValidOutputStride(t), tidy(function () {\n      var n = toInputTensor(e),\n          o = resizeAndPadTo(n, segmentationModelImageDimensions),\n          i = o.resizedAndPadded,\n          s = o.paddedBy,\n          d = a.predictForPartMap(i, t),\n          u = d.segmentScores,\n          l = d.partHeatmapScores,\n          c = i.shape,\n          p = c[0],\n          h = c[1],\n          f = n.shape,\n          v = f[0],\n          m = f[1],\n          g = scaleAndCropToInputTensorShape(u, [v, m], [p, h], s),\n          b = scaleAndCropToInputTensorShape(l, [v, m], [p, h], s);\n      return decodePartSegmentation(toMask(g.squeeze(), r), b);\n    });\n  }, e.prototype.estimatePartSegmentation = function (e, t, r) {\n    return void 0 === t && (t = 16), void 0 === r && (r = .5), __awaiter(this, void 0, void 0, function () {\n      var a, n, o, i, s;\n      return __generator(this, function (d) {\n        switch (d.label) {\n          case 0:\n            return a = this.estimatePartSegmentationActivation(e, t, r), n = a.shape, o = n[0], i = n[1], [4, a.data()];\n\n          case 1:\n            return s = d.sent(), a.dispose(), [2, {\n              height: o,\n              width: i,\n              data: s\n            }];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.mobileNet.dispose();\n  }, e;\n}();\n\nfunction load(e) {\n  return void 0 === e && (e = .75), __awaiter(this, void 0, void 0, function () {\n    var t, r;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.\");\n          return t = Object.keys(checkpoints), util.assert(\"number\" == typeof e, function () {\n            return \"got multiplier type of \" + typeof e + \" when it should be a number.\";\n          }), util.assert(t.indexOf(e.toString()) >= 0, function () {\n            return \"invalid multiplier value of \" + e + \".  No checkpoint exists for that multiplier. Must be one of \" + t.join(\",\") + \".\";\n          }), [4, mobilenetLoader.load(e)];\n\n        case 1:\n          return r = a.sent(), [2, new BodyPix(r)];\n      }\n    });\n  });\n}\n\nvar mobilenetLoader = {\n  load: function (e) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var t, r, a, n;\n      return __generator(this, function (o) {\n        switch (o.label) {\n          case 0:\n            return t = checkpoints[e], r = t.url, [4, loadGraphModel(r + \"model.json\")];\n\n          case 1:\n            return a = o.sent(), n = new ModelWeights(a), [2, new MobileNet(n, t.architecture)];\n        }\n      });\n    });\n  }\n};\n\nfunction cpuBlur(e, t, r) {\n  for (var a = e.getContext(\"2d\"), n = 0, o = 1 / (2 * Math.PI * 5 * 5), i = r < 3 ? 1 : 2, s = -r; s <= r; s += i) for (var d = -r; d <= r; d += i) {\n    n += o * Math.exp(-(d * d + s * s) / 50);\n  }\n\n  for (s = -r; s <= r; s += i) for (d = -r; d <= r; d += i) a.globalAlpha = o * Math.exp(-(d * d + s * s) / 50) / n * r, a.drawImage(t, d, s);\n\n  a.globalAlpha = 1;\n}\n\nvar offScreenCanvases = {};\n\nfunction isSafari() {\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\nfunction assertSameDimensions(e, t, r, a) {\n  var n = e.width,\n      o = e.height,\n      i = t.width,\n      s = t.height;\n  if (n !== i || o !== s) throw new Error(\"error: dimensions must match. \" + r + \" has dimensions \" + n + \"x\" + o + \", \" + a + \" has dimensions \" + i + \"x\" + s);\n}\n\nfunction flipCanvasHorizontal(e) {\n  var t = e.getContext(\"2d\");\n  t.scale(-1, 1), t.translate(-e.width, 0);\n}\n\nfunction drawWithCompositing(e, t, r) {\n  e.globalCompositeOperation = r, e.drawImage(t, 0, 0);\n}\n\nfunction createOffScreenCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction ensureOffscreenCanvasCreated(e) {\n  return offScreenCanvases[e] || (offScreenCanvases[e] = createOffScreenCanvas()), offScreenCanvases[e];\n}\n\nfunction drawAndBlurImageOnCanvas(e, t, r) {\n  var a = e.height,\n      n = e.width,\n      o = r.getContext(\"2d\");\n  r.width = n, r.height = a, o.clearRect(0, 0, n, a), o.save(), isSafari() ? cpuBlur(r, e, t) : (o.filter = \"blur(\" + t + \"px)\", o.drawImage(e, 0, 0, n, a)), o.restore();\n}\n\nfunction drawAndBlurImageOnOffScreenCanvas(e, t, r) {\n  var a = ensureOffscreenCanvasCreated(r);\n  return 0 === t ? renderImageToCanvas(e, a) : drawAndBlurImageOnCanvas(e, t, a), a;\n}\n\nfunction renderImageToCanvas(e, t) {\n  var r = e.width,\n      a = e.height;\n  t.width = r, t.height = a, t.getContext(\"2d\").drawImage(e, 0, 0, r, a);\n}\n\nfunction renderImageDataToCanvas(e, t) {\n  t.width = e.width, t.height = e.height, t.getContext(\"2d\").putImageData(e, 0, 0);\n}\n\nfunction renderImageDataToOffScreenCanvas(e, t) {\n  var r = ensureOffscreenCanvasCreated(t);\n  return renderImageDataToCanvas(e, r), r;\n}\n\nfunction toMaskImageData(e, t) {\n  void 0 === t && (t = !0);\n\n  for (var r = e.width, a = e.height, n = e.data, o = new Uint8ClampedArray(r * a * 4), i = 0; i < a * r; ++i) {\n    var s = 255 * (t ? 1 - n[i] : n[i]),\n        d = 4 * i;\n    o[d + 0] = 0, o[d + 1] = 0, o[d + 2] = 0, o[d + 3] = Math.round(s);\n  }\n\n  return new ImageData(o, r, a);\n}\n\nfunction toColoredPartImageData(e, t) {\n  for (var r = e.width, a = e.height, n = e.data, o = new Uint8ClampedArray(r * a * 4), i = 0; i < a * r; ++i) {\n    var s = Math.round(n[i]),\n        d = 4 * i;\n    if (-1 === s) o[d + 0] = 255, o[d + 1] = 255, o[d + 2] = 255, o[d + 3] = 255;else {\n      var u = t[s];\n      if (!u) throw new Error(\"No color could be found for part id \" + s);\n      o[d + 0] = u[0], o[d + 1] = u[1], o[d + 2] = u[2], o[d + 3] = 255;\n    }\n  }\n\n  return new ImageData(o, r, a);\n}\n\nvar CANVAS_NAMES = {\n  blurred: \"blurred\",\n  blurredMask: \"blurred-mask\",\n  mask: \"mask\",\n  lowresPartMask: \"lowres-part-mask\"\n};\n\nfunction drawMask(e, t, r, a, n, o) {\n  void 0 === a && (a = .7), void 0 === n && (n = 0), void 0 === o && (o = !1), assertSameDimensions(t, r, \"image\", \"mask\");\n  var i = drawAndBlurImageOnOffScreenCanvas(renderImageDataToOffScreenCanvas(r, CANVAS_NAMES.mask), n, CANVAS_NAMES.blurredMask);\n  e.width = i.width, e.height = i.height;\n  var s = e.getContext(\"2d\");\n  s.save(), o && flipCanvasHorizontal(e), s.drawImage(t, 0, 0), s.globalAlpha = a, s.drawImage(i, 0, 0), s.restore();\n}\n\nfunction drawPixelatedMask(e, t, r, a, n, o, i) {\n  void 0 === a && (a = .7), void 0 === n && (n = 0), void 0 === o && (o = !1), void 0 === i && (i = 10), assertSameDimensions(t, r, \"image\", \"mask\");\n  var s = drawAndBlurImageOnOffScreenCanvas(renderImageDataToOffScreenCanvas(r, CANVAS_NAMES.mask), n, CANVAS_NAMES.blurredMask);\n  e.width = s.width, e.height = s.height;\n  var d = e.getContext(\"2d\");\n  d.save(), o && flipCanvasHorizontal(e);\n  var u = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask),\n      l = u.getContext(\"2d\");\n  u.width = s.width * (1 / i), u.height = s.height * (1 / i), l.drawImage(s, 0, 0, s.width, s.height, 0, 0, u.width, u.height), d.imageSmoothingEnabled = !1, d.drawImage(u, 0, 0, u.width, u.height, 0, 0, e.width, e.height);\n\n  for (var c = 0; c < u.width; c++) d.beginPath(), d.strokeStyle = \"#ffffff\", d.moveTo(i * c, 0), d.lineTo(i * c, e.height), d.stroke();\n\n  for (c = 0; c < u.height; c++) d.beginPath(), d.strokeStyle = \"#ffffff\", d.moveTo(0, i * c), d.lineTo(e.width, i * c), d.stroke();\n\n  d.globalAlpha = 1 - a, d.drawImage(t, 0, 0), d.restore();\n}\n\nfunction createPersonMask(e, t) {\n  var r = renderImageDataToOffScreenCanvas(toMaskImageData(e, !1), CANVAS_NAMES.mask);\n  return 0 === t ? r : drawAndBlurImageOnOffScreenCanvas(r, t, CANVAS_NAMES.blurredMask);\n}\n\nfunction drawBokehEffect(e, t, r, a, n, o) {\n  void 0 === a && (a = 3), void 0 === n && (n = 3), void 0 === o && (o = !1), assertSameDimensions(t, r, \"image\", \"segmentation\");\n  var i = drawAndBlurImageOnOffScreenCanvas(t, a, CANVAS_NAMES.blurred),\n      s = createPersonMask(r, n),\n      d = e.getContext(\"2d\");\n  d.save(), o && flipCanvasHorizontal(e), d.drawImage(t, 0, 0), drawWithCompositing(d, s, \"destination-in\"), drawWithCompositing(d, i, \"destination-over\"), d.restore();\n}\n\nvar partChannels = [\"leftFace\", \"rightFace\", \"rightUpperLegFront\", \"rightLowerLegBack\", \"rightUpperLegBack\", \"leftLowerLegFront\", \"leftUpperLegFront\", \"leftUpperLegBack\", \"leftLowerLegBack\", \"rightFeet\", \"rightLowerLegFront\", \"leftFeet\", \"torsoFront\", \"torsoBack\", \"rightUpperArmFront\", \"rightUpperArmBack\", \"rightLowerArmBack\", \"leftLowerArmFront\", \"leftUpperArmFront\", \"leftUpperArmBack\", \"leftLowerArmBack\", \"rightHand\", \"rightLowerArmFront\", \"leftHand\"];\nexport { BodyPix, load, checkpoints, decodePartSegmentation, toMask, drawBokehEffect, drawMask, drawPixelatedMask, toColoredPartImageData, toMaskImageData, partChannels, resizeAndPadTo, scaleAndCropToInputTensorShape };","map":null,"metadata":{},"sourceType":"module"}
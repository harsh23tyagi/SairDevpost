{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar parser = require('socket.io-parser');\n\nvar debug = require('debug')('socket.io:client');\n\nvar url = require('url');\n/**\n * Module exports.\n */\n\n\nmodule.exports = Client;\n/**\n * Client constructor.\n *\n * @param {Server} server instance\n * @param {Socket} conn\n * @api private\n */\n\nfunction Client(server, conn) {\n  this.server = server;\n  this.conn = conn;\n  this.encoder = server.encoder;\n  this.decoder = new server.parser.Decoder();\n  this.id = conn.id;\n  this.request = conn.request;\n  this.setup();\n  this.sockets = {};\n  this.nsps = {};\n  this.connectBuffer = [];\n}\n/**\n * Sets up event listeners.\n *\n * @api private\n */\n\n\nClient.prototype.setup = function () {\n  this.onclose = this.onclose.bind(this);\n  this.ondata = this.ondata.bind(this);\n  this.onerror = this.onerror.bind(this);\n  this.ondecoded = this.ondecoded.bind(this);\n  this.decoder.on('decoded', this.ondecoded);\n  this.conn.on('data', this.ondata);\n  this.conn.on('error', this.onerror);\n  this.conn.on('close', this.onclose);\n};\n/**\n * Connects a client to a namespace.\n *\n * @param {String} name namespace\n * @param {Object} query the query parameters\n * @api private\n */\n\n\nClient.prototype.connect = function (name, query) {\n  if (this.server.nsps[name]) {\n    debug('connecting to namespace %s', name);\n    return this.doConnect(name, query);\n  }\n\n  this.server.checkNamespace(name, query, dynamicNsp => {\n    if (dynamicNsp) {\n      debug('dynamic namespace %s was created', dynamicNsp.name);\n      this.doConnect(name, query);\n    } else {\n      debug('creation of namespace %s was denied', name);\n      this.packet({\n        type: parser.ERROR,\n        nsp: name,\n        data: 'Invalid namespace'\n      });\n    }\n  });\n};\n/**\n * Connects a client to a namespace.\n *\n * @param {String} name namespace\n * @param {String} query the query parameters\n * @api private\n */\n\n\nClient.prototype.doConnect = function (name, query) {\n  var nsp = this.server.of(name);\n\n  if ('/' != name && !this.nsps['/']) {\n    this.connectBuffer.push(name);\n    return;\n  }\n\n  var self = this;\n  var socket = nsp.add(this, query, function () {\n    self.sockets[socket.id] = socket;\n    self.nsps[nsp.name] = socket;\n\n    if ('/' == nsp.name && self.connectBuffer.length > 0) {\n      self.connectBuffer.forEach(self.connect, self);\n      self.connectBuffer = [];\n    }\n  });\n};\n/**\n * Disconnects from all namespaces and closes transport.\n *\n * @api private\n */\n\n\nClient.prototype.disconnect = function () {\n  for (var id in this.sockets) {\n    if (this.sockets.hasOwnProperty(id)) {\n      this.sockets[id].disconnect();\n    }\n  }\n\n  this.sockets = {};\n  this.close();\n};\n/**\n * Removes a socket. Called by each `Socket`.\n *\n * @api private\n */\n\n\nClient.prototype.remove = function (socket) {\n  if (this.sockets.hasOwnProperty(socket.id)) {\n    var nsp = this.sockets[socket.id].nsp.name;\n    delete this.sockets[socket.id];\n    delete this.nsps[nsp];\n  } else {\n    debug('ignoring remove for %s', socket.id);\n  }\n};\n/**\n * Closes the underlying connection.\n *\n * @api private\n */\n\n\nClient.prototype.close = function () {\n  if ('open' == this.conn.readyState) {\n    debug('forcing transport close');\n    this.conn.close();\n    this.onclose('forced server close');\n  }\n};\n/**\n * Writes a packet to the transport.\n *\n * @param {Object} packet object\n * @param {Object} opts\n * @api private\n */\n\n\nClient.prototype.packet = function (packet, opts) {\n  opts = opts || {};\n  var self = this; // this writes to the actual connection\n\n  function writeToEngine(encodedPackets) {\n    if (opts.volatile && !self.conn.transport.writable) return;\n\n    for (var i = 0; i < encodedPackets.length; i++) {\n      self.conn.write(encodedPackets[i], {\n        compress: opts.compress\n      });\n    }\n  }\n\n  if ('open' == this.conn.readyState) {\n    debug('writing packet %j', packet);\n\n    if (!opts.preEncoded) {\n      // not broadcasting, need to encode\n      this.encoder.encode(packet, writeToEngine); // encode, then write results to engine\n    } else {\n      // a broadcast pre-encodes a packet\n      writeToEngine(packet);\n    }\n  } else {\n    debug('ignoring packet write %j', packet);\n  }\n};\n/**\n * Called with incoming transport data.\n *\n * @api private\n */\n\n\nClient.prototype.ondata = function (data) {\n  // try/catch is needed for protocol violations (GH-1880)\n  try {\n    this.decoder.add(data);\n  } catch (e) {\n    this.onerror(e);\n  }\n};\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\n\nClient.prototype.ondecoded = function (packet) {\n  if (parser.CONNECT == packet.type) {\n    this.connect(url.parse(packet.nsp).pathname, url.parse(packet.nsp, true).query);\n  } else {\n    var socket = this.nsps[packet.nsp];\n\n    if (socket) {\n      process.nextTick(function () {\n        socket.onpacket(packet);\n      });\n    } else {\n      debug('no socket for namespace %s', packet.nsp);\n    }\n  }\n};\n/**\n * Handles an error.\n *\n * @param {Object} err object\n * @api private\n */\n\n\nClient.prototype.onerror = function (err) {\n  for (var id in this.sockets) {\n    if (this.sockets.hasOwnProperty(id)) {\n      this.sockets[id].onerror(err);\n    }\n  }\n\n  this.conn.close();\n};\n/**\n * Called upon transport close.\n *\n * @param {String} reason\n * @api private\n */\n\n\nClient.prototype.onclose = function (reason) {\n  debug('client close with reason %s', reason); // ignore a potential subsequent `close` event\n\n  this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly\n\n  for (var id in this.sockets) {\n    if (this.sockets.hasOwnProperty(id)) {\n      this.sockets[id].onclose(reason);\n    }\n  }\n\n  this.sockets = {};\n  this.decoder.destroy(); // clean up decoder\n};\n/**\n * Cleans up event listeners.\n *\n * @api private\n */\n\n\nClient.prototype.destroy = function () {\n  this.conn.removeListener('data', this.ondata);\n  this.conn.removeListener('error', this.onerror);\n  this.conn.removeListener('close', this.onclose);\n  this.decoder.removeListener('decoded', this.ondecoded);\n};","map":null,"metadata":{},"sourceType":"script"}
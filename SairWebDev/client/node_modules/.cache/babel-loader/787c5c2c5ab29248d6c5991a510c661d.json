{"ast":null,"code":"var _jsxFileName = \"/Users/harshtyagi/Documents/Sair/React2/Middleware/client/src/components/VideoChatting/ScreenRecord.js\";\nimport React from \"react\"; // import axios from \"axios\";\n// import img from \"./image1.jpg\";\n\nimport * as bodyPix from \"@tensorflow-models/body-pix\";\nimport \"../../Self.css\";\nimport * as partColorScales from \"./color_scheme\"; // New Imports for videoSegmentation\n\nimport dat from \"dat.gui\";\nimport Stats from \"stats.js\"; //End of imports\n// ------Begin coding video demo------\n\nconst stats = new Stats();\nconst state = {\n  video: null,\n  strem: null,\n  net: null,\n  videoConstraints: {},\n  changingCamera: false,\n  changingArchitecture: false\n};\nvar flag = false;\n\nconst startRecording = e => {\n  e.preventDefault();\n  console.log(\"Starting to record\");\n  flag = true;\n  const btn = document.getElementById(\"stopRec\");\n  btn.textContent = \"Stop Recording..\";\n  const canv = document.getElementById(\"output\");\n  var stream = canv.captureStream(25);\n  let mediaRecorder = new MediaRecorder(stream);\n  mediaRecorder.start();\n  console.log(\"Started Recording\");\n  let chunks = [];\n\n  mediaRecorder.ondataavailable = function (ev) {\n    chunks.push(ev.data);\n    console.log(\"Pushing data\");\n  };\n\n  btn.addEventListener(\"click\", ev => {\n    ev.preventDefault();\n\n    if (flag) {\n      console.log(\"Trying to Stop\");\n      mediaRecorder.stop();\n      flag = false;\n    }\n  });\n  const vidsav = document.getElementById(\"bijli\");\n\n  mediaRecorder.onStop = e => {\n    let blob = new Blob(chunks, {\n      type: \"video/mp4\"\n    });\n    console.log(blob);\n    chunks = [];\n    let videoURL = window.URL.createObjectURL(blob);\n    vidsav.src = videoURL;\n  };\n};\n\nconst stopRecording = e => {\n  e.preventDefault();\n}; //Checking the type of device: Mobile or not- if mobile then android or IoS\n\n\nfunction isAndroid() {\n  return /Android/i.test(navigator.userAgent);\n}\n\nfunction isiOS() {\n  return /iPhone|iPad|iPod/i.test(navigator.userAgent);\n}\n\nfunction isMobile() {\n  return isAndroid() || isiOS();\n}\n\nasync function getVideoInputs() {\n  console.log(\"Checking Devices\");\n\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    console.log(\"enumerateDevices() not supported.\");\n    return [];\n  }\n\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const videoDevices = devices.filter(device => device.kind === \"videoinput\");\n  console.log(videoDevices);\n  return videoDevices;\n}\n\nfunction stopExistingVideoCapture() {\n  if (state.video && state.video.srcObject) {\n    state.video.srcObject.getTracks().forEach(track => {\n      track.stop();\n    });\n    state.video.srcObject = null;\n  }\n}\n\nasync function getDeviceIdForLabel(cameraLabel) {\n  // event.preventDefault(); //remove this line whenever you want to load the next page\n  const videoInputs = await getVideoInputs();\n  console.log(\"CamerLabel\" + cameraLabel);\n\n  for (let i = 0; i < videoInputs.length; i++) {\n    const videoInput = videoInputs[i];\n\n    if (videoInput.label === cameraLabel) {\n      console.log(\"Camera Found: \");\n      console.log(videoInput);\n      console.log(videoInput.label);\n      return videoInput.deviceId;\n    }\n  }\n\n  return null;\n}\n\nfunction getFacingMode(cameraLabel) {\n  if (!cameraLabel) {\n    return \"user\";\n  }\n\n  if (cameraLabel.toLowerCase().includes(\"back\")) {\n    return \"environment\";\n  } else {\n    return \"user\";\n  }\n}\n\nasync function getConstraints(cameraLabel) {\n  let deviceId;\n  let facingMode;\n\n  if (cameraLabel) {\n    deviceId = await getDeviceIdForLabel(cameraLabel); // on mobile, use the facing mode based on the camera.\n\n    facingMode = isMobile() ? getFacingMode(cameraLabel) : null;\n  }\n\n  return {\n    deviceId,\n    facingMode\n  };\n}\n\nasync function setupCamera(cameraLabel) {\n  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n    throw new Error(\"Browser API navigator.mediaDevices.getUserMedia not available\");\n  }\n\n  const videoElement = document.getElementById(\"video\");\n  stopExistingVideoCapture();\n  const videoConstraints = await getConstraints(cameraLabel);\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: false,\n    video: videoConstraints\n  });\n  videoElement.srcObject = stream;\n  return new Promise(resolve => {\n    videoElement.onloadedmetadata = () => {\n      videoElement.width = videoElement.videoWidth;\n      videoElement.height = videoElement.videoHeight;\n      resolve(videoElement);\n    };\n  });\n}\n\nasync function loadVideo(cameraLabel) {\n  try {\n    state.video = await setupCamera(cameraLabel);\n  } catch (e) {\n    let info = document.getElementById(\"info\");\n    info.textContent = \"this browser does not support video capture,\" + \"or this device does not have a camera\";\n    info.style.display = \"block\";\n    throw e;\n  }\n\n  state.video.play();\n}\n\nconst guiState = {\n  estimate: \"segmentation\",\n  camera: null,\n  flipHorizontal: true,\n  input: {\n    mobileNetArchitecture: isMobile() ? \"0.50\" : \"0.75\",\n    outputStride: 16\n  },\n  segmentation: {\n    segmentationThreshold: 0.5,\n    effect: \"mask\",\n    maskBackground: true,\n    opacity: 0.7,\n    backgroundBlurAmount: 3,\n    maskBlurAmount: 0,\n    edgeBlurAmount: 3\n  },\n  partMap: {\n    colorScale: \"rainbow\",\n    segmentationThreshold: 0.5,\n    applyPixelation: false,\n    opacity: 0.9\n  },\n  showFps: !isMobile()\n};\n\nfunction toCameraOptions(cameras) {\n  const result = {\n    default: null\n  };\n  cameras.forEach(camera => {\n    result[camera.label] = camera.label;\n  });\n  return result;\n} // Setting up GUI\n\n\nfunction setupGui(cameras) {\n  const gui = new dat.GUI({\n    width: 300\n  });\n  gui.add(guiState, \"camera\", toCameraOptions(cameras)).onChange(async function (cameraLabel) {\n    state.changingCamera = true;\n    await loadVideo(cameraLabel);\n    state.changingCamera = false;\n  });\n  gui.add(guiState, \"flipHorizontal\"); // Architecture: there are a few BodyPix models varying in size and\n  // accuracy. 1.00 is the largest, but will be the slowest. 0.25 is the\n  // fastest, but least accurate.\n\n  gui.add(guiState.input, \"mobileNetArchitecture\", [\"1.00\", \"0.75\", \"0.50\", \"0.25\"]).onChange(async function (architecture) {\n    state.changingArchitecture = true; // Important to purge variables and free\n    // up GPU memory\n\n    state.net.dispose(); // Load the PoseNet model weights for\n    // either the 0.50, 0.75, 1.00, or 1.01\n    // version\n\n    state.net = await bodyPix.load(+architecture);\n    state.changingArchitecture = false;\n  }); // Output stride:  Internally, this parameter affects the height and width\n  // of the layers in the neural network. The lower the value of the output\n  // stride the higher the accuracy but slower the speed, the higher the value\n  // the faster the speed but lower the accuracy.\n\n  gui.add(guiState.input, \"outputStride\", [8, 16, 32]);\n  const estimateController = gui.add(guiState, \"estimate\", [\"segmentation\", \"partmap\"]);\n  let segmentation = gui.addFolder(\"Segmentation\");\n  segmentation.add(guiState.segmentation, \"segmentationThreshold\", 0.0, 1.0);\n  const segmentationEffectController = segmentation.add(guiState.segmentation, \"effect\", [\"mask\", \"bokeh\"]);\n  segmentation.open();\n  let darknessLevel;\n  let bokehBlurAmount;\n  let edgeBlurAmount;\n  let maskBlurAmount;\n  let maskBackground;\n  segmentationEffectController.onChange(function (effectType) {\n    if (effectType === \"mask\") {\n      if (bokehBlurAmount) {\n        bokehBlurAmount.remove();\n      }\n\n      if (edgeBlurAmount) {\n        edgeBlurAmount.remove();\n      }\n\n      darknessLevel = segmentation.add(guiState.segmentation, \"opacity\", 0.0, 1.0);\n      maskBlurAmount = segmentation.add(guiState.segmentation, \"maskBlurAmount\").min(0).max(20).step(1);\n      maskBackground = segmentation.add(guiState.segmentation, \"maskBackground\");\n    } else if (effectType === \"bokeh\") {\n      if (darknessLevel) {\n        darknessLevel.remove();\n      }\n\n      if (maskBlurAmount) {\n        maskBlurAmount.remove();\n      }\n\n      if (maskBackground) {\n        maskBackground.remove();\n      }\n\n      bokehBlurAmount = segmentation.add(guiState.segmentation, \"backgroundBlurAmount\").min(1).max(20).step(1);\n      edgeBlurAmount = segmentation.add(guiState.segmentation, \"edgeBlurAmount\").min(0).max(20).step(1);\n    }\n  }); // manually set the effect so that the options are shown.\n\n  segmentationEffectController.setValue(guiState.segmentation.effect);\n  let partMap = gui.addFolder(\"Part Map\");\n  partMap.add(guiState.partMap, \"segmentationThreshold\", 0.0, 1.0);\n  partMap.add(guiState.partMap, \"applyPixelation\");\n  partMap.add(guiState.partMap, \"opacity\", 0.0, 1.0);\n  partMap.add(guiState.partMap, \"colorScale\", Object.keys(partColorScales)).onChange(colorScale => {\n    setShownPartColorScales(colorScale);\n  });\n  setShownPartColorScales(guiState.partMap.colorScale);\n  estimateController.onChange(function (estimationType) {\n    if (estimationType === \"segmentation\") {\n      segmentation.open();\n      partMap.close();\n      document.getElementById(\"colors\").style.display = \"none\";\n    } else {\n      segmentation.close();\n      partMap.open();\n      document.getElementById(\"colors\").style.display = \"inline-block\";\n    }\n  });\n  gui.add(guiState, \"showFps\").onChange(showFps => {\n    if (showFps) {\n      document.body.appendChild(stats.dom);\n    } else {\n      document.body.removeChild(stats.dom);\n    }\n  });\n}\n\nfunction setShownPartColorScales(colorScale) {\n  const colors = document.getElementById(\"colors\");\n  colors.innerHTML = \"\";\n  const partColors = partColorScales[colorScale];\n  const partNames = bodyPix.partChannels;\n\n  for (let i = 0; i < partColors.length; i++) {\n    const partColor = partColors[i];\n    const child = document.createElement(\"li\");\n    child.innerHTML = \"\\n        <div class='color' style='background-color:rgb(\".concat(partColor[0], \",\").concat(partColor[1], \",\").concat(partColor[2], \")' ></div>\\n        \").concat(partNames[i]);\n    colors.appendChild(child);\n  }\n} //--GUI Setup Ends--\n// ---Seting up FPS--\n\n/**\n * Sets up a frames per second panel on the top-left of the window\n */\n\n\nfunction setupFPS() {\n  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n\n  if (guiState.showFps) {\n    document.body.appendChild(stats.dom);\n  }\n} //Body Segmentation in real time\n\n\nfunction segmentBodyInRealTime() {\n  const canvas = document.getElementById(\"output\"); // since images are being fed from a webcam\n\n  async function bodySegmentationFrame() {\n    // if changing the model or the camera, wait a second for it to complete\n    // then try again.\n    if (state.changingArchitecture || state.changingCamera) {\n      setTimeout(bodySegmentationFrame, 1000);\n      return;\n    } // Begin monitoring code for frames per second\n\n\n    stats.begin(); // Scale an image down to a certain factor. Too large of an image will\n    // slow down the GPU\n\n    const outputStride = +guiState.input.outputStride;\n    const flipHorizontally = guiState.flipHorizontal;\n\n    switch (guiState.estimate) {\n      case \"segmentation\":\n        const personSegmentation = await state.net.estimatePersonSegmentation(state.video, outputStride, guiState.segmentation.segmentationThreshold);\n\n        switch (guiState.segmentation.effect) {\n          case \"mask\":\n            const mask = bodyPix.toMaskImageData(personSegmentation, guiState.segmentation.maskBackground);\n            bodyPix.drawMask(canvas, state.video, mask, guiState.segmentation.opacity, guiState.segmentation.maskBlurAmount, flipHorizontally);\n            break;\n\n          case \"bokeh\":\n            bodyPix.drawBokehEffect(canvas, state.video, personSegmentation, +guiState.segmentation.backgroundBlurAmount, guiState.segmentation.edgeBlurAmount, flipHorizontally);\n            break;\n        }\n\n        break;\n\n      case \"partmap\":\n        const partSegmentation = await state.net.estimatePartSegmentation(state.video, outputStride, guiState.partMap.segmentationThreshold);\n        const coloredPartImageData = bodyPix.toColoredPartImageData(partSegmentation, partColorScales[guiState.partMap.colorScale]);\n        const maskBlurAmount = 0;\n\n        if (guiState.partMap.applyPixelation) {\n          const pixelCellWidth = 10.0;\n          bodyPix.drawPixelatedMask(canvas, state.video, //changed here\n          coloredPartImageData, guiState.partMap.opacity, maskBlurAmount, flipHorizontally, pixelCellWidth);\n        } else {\n          bodyPix.drawMask(canvas, state.video, //changed here\n          coloredPartImageData, guiState.opacity, maskBlurAmount, flipHorizontally);\n        }\n\n        break;\n\n      default:\n        break;\n    } // End monitoring code for frames per second\n\n\n    stats.end();\n    requestAnimationFrame(bodySegmentationFrame);\n  }\n\n  bodySegmentationFrame();\n} //--------End Video Demo-------\n\n\nconst videosegmentation = () => {\n  // const loadAndUseBodyPix = async e => {\n  //   // async function loadAndUseBodyPix() {\n  //   e.preventDefault();\n  //   const net = await bodyPix.load();\n  //   // BodyPix model loaded\n  //   const imageElement = document.getElementById(\"image\");\n  //   console.log(\"Loaded\");\n  //   // load the BodyPix model from a checkpoint\n  //   // arguments for estimating person segmentation.\n  //   const outputStride = 16;\n  //   const segmentationThreshold = 0.5;\n  //   const personSegmentation = await net.estimatePersonSegmentation(\n  //     imageElement,\n  //     outputStride,\n  //     segmentationThreshold\n  //   );\n  //   console.log(personSegmentation);\n  //   console.log(\"Reached\");\n  //   console.log(\"Masking the image\");\n  //   // Masking the image\n  //   const segmentation = await net.estimatePersonSegmentation(imageElement);\n  //   const maskBackground = true;\n  //   // Convert the personSegmentation into a mask to darken the background.\n  //   const backgroundDarkeningMask = bodyPix.toMaskImageData(\n  //     personSegmentation,\n  //     maskBackground\n  //   );\n  //   const opacity = 0.7;\n  //   const canvas = document.getElementById(\"canvas\");\n  //   // draw the mask onto the image on a canvas.  With opacity set to 0.7 this will darken the background.\n  //   bodyPix.drawMask(canvas, imageElement, backgroundDarkeningMask, opacity);\n  //   console.log(\"Image Masked\");\n  //   console.log(\"Estimating Part Segmentation...\");\n  //   const partSegmentation = await net.estimatePartSegmentation(\n  //     imageElement,\n  //     outputStride,\n  //     segmentationThreshold\n  //   );\n  //   console.log(\"Part Segmentation Results:\");\n  //   console.log(partSegmentation);\n  // };\n  const demoKickOff = async e => {\n    e.preventDefault();\n    state.net = await bodyPix.load(+guiState.input.mobileNetArchitecture); // document.getElementById(\"loading\").style.display = \"none\";\n\n    document.getElementById(\"main\").style.display = \"inline-block\";\n    await loadVideo();\n    let cameras = await getVideoInputs();\n    setupFPS();\n    setupGui(cameras);\n    segmentBodyInRealTime();\n  };\n\n  return React.createElement(\"div\", {\n    className: \"container\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 575\n    },\n    __self: this\n  }, React.createElement(\"h1\", {\n    className: \"headerVidSeg\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 577\n    },\n    __self: this\n  }, \"Video Segmentation\"), React.createElement(\"div\", {\n    className: \"container\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 586\n    },\n    __self: this\n  }, React.createElement(\"form\", {\n    className: \"form\",\n    onSubmit: e => demoKickOff(e),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 587\n    },\n    __self: this\n  }, React.createElement(\"input\", {\n    type: \"submit\",\n    className: \"btn btn-primary\",\n    value: \"Get Device Label\",\n    required: true,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 588\n    },\n    __self: this\n  })), React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 596\n    },\n    __self: this\n  }, React.createElement(\"form\", {\n    className: \"form\",\n    onSubmit: e => startRecording(e),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 597\n    },\n    __self: this\n  }, React.createElement(\"input\", {\n    type: \"submit\",\n    className: \"btn btn-primary\",\n    value: \"Start Recording\",\n    required: true,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 598\n    },\n    __self: this\n  })), React.createElement(\"input\", {\n    type: \"submit\",\n    className: \"btn btn-primary\",\n    value: \"Stop Recording\",\n    id: \"stopRec\",\n    required: true,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 606\n    },\n    __self: this\n  }))), React.createElement(\"div\", {\n    id: \"stats\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 615\n    },\n    __self: this\n  }), React.createElement(\"div\", {\n    id: \"info\",\n    className: \"info\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 616\n    },\n    __self: this\n  }), React.createElement(\"div\", {\n    id: \"main\",\n    className: \"info\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 618\n    },\n    __self: this\n  }, React.createElement(\"video\", {\n    id: \"video\",\n    className: \"videoClass\",\n    playsInline: true,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 619\n    },\n    __self: this\n  }), React.createElement(\"canvas\", {\n    id: \"output\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 620\n    },\n    __self: this\n  })), React.createElement(\"video\", {\n    id: \"Bijli\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 623\n    },\n    __self: this\n  }), React.createElement(\"ul\", {\n    id: \"colors\",\n    className: \"info\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 624\n    },\n    __self: this\n  }), React.createElement(\"div\", {\n    className: \"footer\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 626\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    className: \"footer-text\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 627\n    },\n    __self: this\n  }, React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 628\n    },\n    __self: this\n  }, \"The BodyPix model can estimate which pixels in an image are part of a person, and which pixels are part of each of 24 body parts. It works on a single person, and such \", React.createElement(\"strong\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 631\n    },\n    __self: this\n  }, \"works best\"), \" when\", \" \", React.createElement(\"strong\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 632\n    },\n    __self: this\n  }, \"one person is present\"), \" in an image.\", React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 633\n    },\n    __self: this\n  }), React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 634\n    },\n    __self: this\n  }), \"The \", React.createElement(\"strong\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 635\n    },\n    __self: this\n  }, \"output stride\"), \" and\", \" \", React.createElement(\"strong\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 636\n    },\n    __self: this\n  }, \"model (indicated by mobileNetArchitecture)\"), \" have the largest effects on accuracy/speed. A \", React.createElement(\"i\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 637\n    },\n    __self: this\n  }, \"higher\"), \" output stride results in lower accuracy but higher speed. A \", React.createElement(\"i\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 638\n    },\n    __self: this\n  }, \"larger\"), \" model, indicated by the \", React.createElement(\"i\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 639\n    },\n    __self: this\n  }, \"mobileNetArchitecture\"), \" dropdown, results in higher accuracy but lower speed.\"), React.createElement(\"div\", {\n    className: \"footer-menu\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 642\n    },\n    __self: this\n  }, React.createElement(\"i\", {\n    className: \"material-icons switch-camera\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 643\n    },\n    __self: this\n  }, \"switch_camera\"), React.createElement(\"i\", {\n    className: \"material-icons mask mode active\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 644\n    },\n    __self: this\n  }, \"portrait\"), React.createElement(\"i\", {\n    className: \"material-icons mode bokeh\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 645\n    },\n    __self: this\n  }, \"blur_on\"), React.createElement(\"i\", {\n    className: \"material-icons mode part-map\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 646\n    },\n    __self: this\n  }, \"format_color_fill\"), React.createElement(\"i\", {\n    className: \"material-icons high-accuracy\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 647\n    },\n    __self: this\n  }, \"high_quality\")))));\n};\n\nconsole.log(\"Hello\");\nconsole.log(\"Bigshot\");\nexport default videosegmentation; // {/* <form className=\"form\" onSubmit={e => loadAndUseBodyPix(e)}>\n\n{\n  /* <h1 className=\"headerVidSeg\">Reached Video Segmentation Page</h1>\n  <div id=\"divid1\">\n  <img src={img} id=\"image\" />\n  </div>\n  <br />\n  <input\n  type=\"submit\"\n  className=\"btn btn-primary\"\n  value=\"Segment Image\"\n  required\n  />\n  </form>\n  <br />\n  <canvas id=\"canvas\" width=\"100%\" />  */\n}","map":{"version":3,"sources":["/Users/harshtyagi/Documents/Sair/React2/Middleware/client/src/components/VideoChatting/ScreenRecord.js"],"names":["React","bodyPix","partColorScales","dat","Stats","stats","state","video","strem","net","videoConstraints","changingCamera","changingArchitecture","flag","startRecording","e","preventDefault","console","log","btn","document","getElementById","textContent","canv","stream","captureStream","mediaRecorder","MediaRecorder","start","chunks","ondataavailable","ev","push","data","addEventListener","stop","vidsav","onStop","blob","Blob","type","videoURL","window","URL","createObjectURL","src","stopRecording","isAndroid","test","navigator","userAgent","isiOS","isMobile","getVideoInputs","mediaDevices","enumerateDevices","devices","videoDevices","filter","device","kind","stopExistingVideoCapture","srcObject","getTracks","forEach","track","getDeviceIdForLabel","cameraLabel","videoInputs","i","length","videoInput","label","deviceId","getFacingMode","toLowerCase","includes","getConstraints","facingMode","setupCamera","getUserMedia","Error","videoElement","audio","Promise","resolve","onloadedmetadata","width","videoWidth","height","videoHeight","loadVideo","info","style","display","play","guiState","estimate","camera","flipHorizontal","input","mobileNetArchitecture","outputStride","segmentation","segmentationThreshold","effect","maskBackground","opacity","backgroundBlurAmount","maskBlurAmount","edgeBlurAmount","partMap","colorScale","applyPixelation","showFps","toCameraOptions","cameras","result","default","setupGui","gui","GUI","add","onChange","architecture","dispose","load","estimateController","addFolder","segmentationEffectController","open","darknessLevel","bokehBlurAmount","effectType","remove","min","max","step","setValue","Object","keys","setShownPartColorScales","estimationType","close","body","appendChild","dom","removeChild","colors","innerHTML","partColors","partNames","partChannels","partColor","child","createElement","setupFPS","showPanel","segmentBodyInRealTime","canvas","bodySegmentationFrame","setTimeout","begin","flipHorizontally","personSegmentation","estimatePersonSegmentation","mask","toMaskImageData","drawMask","drawBokehEffect","partSegmentation","estimatePartSegmentation","coloredPartImageData","toColoredPartImageData","pixelCellWidth","drawPixelatedMask","end","requestAnimationFrame","videosegmentation","demoKickOff"],"mappings":"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","sourcesContent":["import React from \"react\";\n// import axios from \"axios\";\n// import img from \"./image1.jpg\";\nimport * as bodyPix from \"@tensorflow-models/body-pix\";\nimport \"../../Self.css\";\nimport * as partColorScales from \"./color_scheme\";\n// New Imports for videoSegmentation\nimport dat from \"dat.gui\";\nimport Stats from \"stats.js\";\n\n//End of imports\n\n// ------Begin coding video demo------\n\nconst stats = new Stats();\nconst state = {\n  video: null,\n  strem: null,\n  net: null,\n  videoConstraints: {},\n  changingCamera: false,\n  changingArchitecture: false\n};\nvar flag = false;\nconst startRecording = e => {\n  e.preventDefault();\n  console.log(\"Starting to record\");\n  flag = true;\n  const btn = document.getElementById(\"stopRec\");\n  btn.textContent = \"Stop Recording..\";\n  const canv = document.getElementById(\"output\");\n  var stream = canv.captureStream(25);\n  let mediaRecorder = new MediaRecorder(stream);\n  mediaRecorder.start();\n  console.log(\"Started Recording\");\n  let chunks = [];\n  mediaRecorder.ondataavailable = function(ev) {\n    chunks.push(ev.data);\n    console.log(\"Pushing data\");\n  };\n\n  btn.addEventListener(\"click\", ev => {\n    ev.preventDefault();\n\n    if (flag) {\n      console.log(\"Trying to Stop\");\n      mediaRecorder.stop();\n      flag = false;\n    }\n  });\n  const vidsav = document.getElementById(\"bijli\");\n  mediaRecorder.onStop = e => {\n    let blob = new Blob(chunks, { type: \"video/mp4\" });\n    console.log(blob);\n    chunks = [];\n    let videoURL = window.URL.createObjectURL(blob);\n    vidsav.src = videoURL;\n  };\n};\nconst stopRecording = e => {\n  e.preventDefault();\n};\n\n//Checking the type of device: Mobile or not- if mobile then android or IoS\nfunction isAndroid() {\n  return /Android/i.test(navigator.userAgent);\n}\n\nfunction isiOS() {\n  return /iPhone|iPad|iPod/i.test(navigator.userAgent);\n}\n\nfunction isMobile() {\n  return isAndroid() || isiOS();\n}\n\nasync function getVideoInputs() {\n  console.log(\"Checking Devices\");\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    console.log(\"enumerateDevices() not supported.\");\n    return [];\n  }\n\n  const devices = await navigator.mediaDevices.enumerateDevices();\n\n  const videoDevices = devices.filter(device => device.kind === \"videoinput\");\n  console.log(videoDevices);\n  return videoDevices;\n}\n\nfunction stopExistingVideoCapture() {\n  if (state.video && state.video.srcObject) {\n    state.video.srcObject.getTracks().forEach(track => {\n      track.stop();\n    });\n    state.video.srcObject = null;\n  }\n}\n\nasync function getDeviceIdForLabel(cameraLabel) {\n  // event.preventDefault(); //remove this line whenever you want to load the next page\n  const videoInputs = await getVideoInputs();\n  console.log(\"CamerLabel\" + cameraLabel);\n  for (let i = 0; i < videoInputs.length; i++) {\n    const videoInput = videoInputs[i];\n    if (videoInput.label === cameraLabel) {\n      console.log(\"Camera Found: \");\n      console.log(videoInput);\n      console.log(videoInput.label);\n      return videoInput.deviceId;\n    }\n  }\n\n  return null;\n}\n\nfunction getFacingMode(cameraLabel) {\n  if (!cameraLabel) {\n    return \"user\";\n  }\n  if (cameraLabel.toLowerCase().includes(\"back\")) {\n    return \"environment\";\n  } else {\n    return \"user\";\n  }\n}\n\nasync function getConstraints(cameraLabel) {\n  let deviceId;\n  let facingMode;\n\n  if (cameraLabel) {\n    deviceId = await getDeviceIdForLabel(cameraLabel);\n    // on mobile, use the facing mode based on the camera.\n    facingMode = isMobile() ? getFacingMode(cameraLabel) : null;\n  }\n  return { deviceId, facingMode };\n}\n\nasync function setupCamera(cameraLabel) {\n  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n    throw new Error(\n      \"Browser API navigator.mediaDevices.getUserMedia not available\"\n    );\n  }\n\n  const videoElement = document.getElementById(\"video\");\n\n  stopExistingVideoCapture();\n\n  const videoConstraints = await getConstraints(cameraLabel);\n\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: false,\n    video: videoConstraints\n  });\n  videoElement.srcObject = stream;\n\n  return new Promise(resolve => {\n    videoElement.onloadedmetadata = () => {\n      videoElement.width = videoElement.videoWidth;\n      videoElement.height = videoElement.videoHeight;\n      resolve(videoElement);\n    };\n  });\n}\n\nasync function loadVideo(cameraLabel) {\n  try {\n    state.video = await setupCamera(cameraLabel);\n  } catch (e) {\n    let info = document.getElementById(\"info\");\n    info.textContent =\n      \"this browser does not support video capture,\" +\n      \"or this device does not have a camera\";\n    info.style.display = \"block\";\n    throw e;\n  }\n\n  state.video.play();\n}\n\nconst guiState = {\n  estimate: \"segmentation\",\n  camera: null,\n  flipHorizontal: true,\n  input: {\n    mobileNetArchitecture: isMobile() ? \"0.50\" : \"0.75\",\n    outputStride: 16\n  },\n  segmentation: {\n    segmentationThreshold: 0.5,\n    effect: \"mask\",\n    maskBackground: true,\n    opacity: 0.7,\n    backgroundBlurAmount: 3,\n    maskBlurAmount: 0,\n    edgeBlurAmount: 3\n  },\n  partMap: {\n    colorScale: \"rainbow\",\n    segmentationThreshold: 0.5,\n    applyPixelation: false,\n    opacity: 0.9\n  },\n  showFps: !isMobile()\n};\n\nfunction toCameraOptions(cameras) {\n  const result = { default: null };\n\n  cameras.forEach(camera => {\n    result[camera.label] = camera.label;\n  });\n\n  return result;\n}\n\n// Setting up GUI\nfunction setupGui(cameras) {\n  const gui = new dat.GUI({ width: 300 });\n\n  gui\n    .add(guiState, \"camera\", toCameraOptions(cameras))\n    .onChange(async function(cameraLabel) {\n      state.changingCamera = true;\n\n      await loadVideo(cameraLabel);\n\n      state.changingCamera = false;\n    });\n\n  gui.add(guiState, \"flipHorizontal\");\n\n  // Architecture: there are a few BodyPix models varying in size and\n  // accuracy. 1.00 is the largest, but will be the slowest. 0.25 is the\n  // fastest, but least accurate.\n  gui\n    .add(guiState.input, \"mobileNetArchitecture\", [\n      \"1.00\",\n      \"0.75\",\n      \"0.50\",\n      \"0.25\"\n    ])\n    .onChange(async function(architecture) {\n      state.changingArchitecture = true;\n      // Important to purge variables and free\n      // up GPU memory\n      state.net.dispose();\n\n      // Load the PoseNet model weights for\n      // either the 0.50, 0.75, 1.00, or 1.01\n      // version\n      state.net = await bodyPix.load(+architecture);\n\n      state.changingArchitecture = false;\n    });\n\n  // Output stride:  Internally, this parameter affects the height and width\n  // of the layers in the neural network. The lower the value of the output\n  // stride the higher the accuracy but slower the speed, the higher the value\n  // the faster the speed but lower the accuracy.\n  gui.add(guiState.input, \"outputStride\", [8, 16, 32]);\n\n  const estimateController = gui.add(guiState, \"estimate\", [\n    \"segmentation\",\n    \"partmap\"\n  ]);\n\n  let segmentation = gui.addFolder(\"Segmentation\");\n  segmentation.add(guiState.segmentation, \"segmentationThreshold\", 0.0, 1.0);\n  const segmentationEffectController = segmentation.add(\n    guiState.segmentation,\n    \"effect\",\n    [\"mask\", \"bokeh\"]\n  );\n\n  segmentation.open();\n\n  let darknessLevel;\n  let bokehBlurAmount;\n  let edgeBlurAmount;\n  let maskBlurAmount;\n  let maskBackground;\n\n  segmentationEffectController.onChange(function(effectType) {\n    if (effectType === \"mask\") {\n      if (bokehBlurAmount) {\n        bokehBlurAmount.remove();\n      }\n      if (edgeBlurAmount) {\n        edgeBlurAmount.remove();\n      }\n      darknessLevel = segmentation.add(\n        guiState.segmentation,\n        \"opacity\",\n        0.0,\n        1.0\n      );\n      maskBlurAmount = segmentation\n        .add(guiState.segmentation, \"maskBlurAmount\")\n        .min(0)\n        .max(20)\n        .step(1);\n      maskBackground = segmentation.add(\n        guiState.segmentation,\n        \"maskBackground\"\n      );\n    } else if (effectType === \"bokeh\") {\n      if (darknessLevel) {\n        darknessLevel.remove();\n      }\n      if (maskBlurAmount) {\n        maskBlurAmount.remove();\n      }\n      if (maskBackground) {\n        maskBackground.remove();\n      }\n      bokehBlurAmount = segmentation\n        .add(guiState.segmentation, \"backgroundBlurAmount\")\n        .min(1)\n        .max(20)\n        .step(1);\n      edgeBlurAmount = segmentation\n        .add(guiState.segmentation, \"edgeBlurAmount\")\n        .min(0)\n        .max(20)\n        .step(1);\n    }\n  });\n\n  // manually set the effect so that the options are shown.\n  segmentationEffectController.setValue(guiState.segmentation.effect);\n\n  let partMap = gui.addFolder(\"Part Map\");\n  partMap.add(guiState.partMap, \"segmentationThreshold\", 0.0, 1.0);\n  partMap.add(guiState.partMap, \"applyPixelation\");\n  partMap.add(guiState.partMap, \"opacity\", 0.0, 1.0);\n  partMap\n    .add(guiState.partMap, \"colorScale\", Object.keys(partColorScales))\n    .onChange(colorScale => {\n      setShownPartColorScales(colorScale);\n    });\n  setShownPartColorScales(guiState.partMap.colorScale);\n\n  estimateController.onChange(function(estimationType) {\n    if (estimationType === \"segmentation\") {\n      segmentation.open();\n      partMap.close();\n      document.getElementById(\"colors\").style.display = \"none\";\n    } else {\n      segmentation.close();\n      partMap.open();\n      document.getElementById(\"colors\").style.display = \"inline-block\";\n    }\n  });\n\n  gui.add(guiState, \"showFps\").onChange(showFps => {\n    if (showFps) {\n      document.body.appendChild(stats.dom);\n    } else {\n      document.body.removeChild(stats.dom);\n    }\n  });\n}\n\nfunction setShownPartColorScales(colorScale) {\n  const colors = document.getElementById(\"colors\");\n  colors.innerHTML = \"\";\n\n  const partColors = partColorScales[colorScale];\n  const partNames = bodyPix.partChannels;\n\n  for (let i = 0; i < partColors.length; i++) {\n    const partColor = partColors[i];\n    const child = document.createElement(\"li\");\n\n    child.innerHTML = `\n        <div class='color' style='background-color:rgb(${partColor[0]},${\n      partColor[1]\n    },${partColor[2]})' ></div>\n        ${partNames[i]}`;\n\n    colors.appendChild(child);\n  }\n}\n//--GUI Setup Ends--\n\n// ---Seting up FPS--\n/**\n * Sets up a frames per second panel on the top-left of the window\n */\nfunction setupFPS() {\n  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n  if (guiState.showFps) {\n    document.body.appendChild(stats.dom);\n  }\n}\n\n//Body Segmentation in real time\nfunction segmentBodyInRealTime() {\n  const canvas = document.getElementById(\"output\");\n  // since images are being fed from a webcam\n\n  async function bodySegmentationFrame() {\n    // if changing the model or the camera, wait a second for it to complete\n    // then try again.\n    if (state.changingArchitecture || state.changingCamera) {\n      setTimeout(bodySegmentationFrame, 1000);\n      return;\n    }\n\n    // Begin monitoring code for frames per second\n    stats.begin();\n\n    // Scale an image down to a certain factor. Too large of an image will\n    // slow down the GPU\n    const outputStride = +guiState.input.outputStride;\n\n    const flipHorizontally = guiState.flipHorizontal;\n\n    switch (guiState.estimate) {\n      case \"segmentation\":\n        const personSegmentation = await state.net.estimatePersonSegmentation(\n          state.video,\n          outputStride,\n          guiState.segmentation.segmentationThreshold\n        );\n\n        switch (guiState.segmentation.effect) {\n          case \"mask\":\n            const mask = bodyPix.toMaskImageData(\n              personSegmentation,\n              guiState.segmentation.maskBackground\n            );\n            bodyPix.drawMask(\n              canvas,\n              state.video,\n              mask,\n              guiState.segmentation.opacity,\n              guiState.segmentation.maskBlurAmount,\n              flipHorizontally\n            );\n\n            break;\n          case \"bokeh\":\n            bodyPix.drawBokehEffect(\n              canvas,\n              state.video,\n              personSegmentation,\n              +guiState.segmentation.backgroundBlurAmount,\n              guiState.segmentation.edgeBlurAmount,\n              flipHorizontally\n            );\n            break;\n        }\n        break;\n      case \"partmap\":\n        const partSegmentation = await state.net.estimatePartSegmentation(\n          state.video,\n          outputStride,\n          guiState.partMap.segmentationThreshold\n        );\n\n        const coloredPartImageData = bodyPix.toColoredPartImageData(\n          partSegmentation,\n          partColorScales[guiState.partMap.colorScale]\n        );\n\n        const maskBlurAmount = 0;\n        if (guiState.partMap.applyPixelation) {\n          const pixelCellWidth = 10.0;\n\n          bodyPix.drawPixelatedMask(\n            canvas,\n            state.video, //changed here\n            coloredPartImageData,\n            guiState.partMap.opacity,\n            maskBlurAmount,\n            flipHorizontally,\n            pixelCellWidth\n          );\n        } else {\n          bodyPix.drawMask(\n            canvas,\n            state.video, //changed here\n            coloredPartImageData,\n            guiState.opacity,\n            maskBlurAmount,\n            flipHorizontally\n          );\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    // End monitoring code for frames per second\n    stats.end();\n\n    requestAnimationFrame(bodySegmentationFrame);\n  }\n\n  bodySegmentationFrame();\n}\n//--------End Video Demo-------\n\nconst videosegmentation = () => {\n  // const loadAndUseBodyPix = async e => {\n  //   // async function loadAndUseBodyPix() {\n  //   e.preventDefault();\n  //   const net = await bodyPix.load();\n  //   // BodyPix model loaded\n  //   const imageElement = document.getElementById(\"image\");\n  //   console.log(\"Loaded\");\n  //   // load the BodyPix model from a checkpoint\n\n  //   // arguments for estimating person segmentation.\n  //   const outputStride = 16;\n  //   const segmentationThreshold = 0.5;\n\n  //   const personSegmentation = await net.estimatePersonSegmentation(\n  //     imageElement,\n  //     outputStride,\n  //     segmentationThreshold\n  //   );\n  //   console.log(personSegmentation);\n  //   console.log(\"Reached\");\n\n  //   console.log(\"Masking the image\");\n  //   // Masking the image\n  //   const segmentation = await net.estimatePersonSegmentation(imageElement);\n\n  //   const maskBackground = true;\n  //   // Convert the personSegmentation into a mask to darken the background.\n  //   const backgroundDarkeningMask = bodyPix.toMaskImageData(\n  //     personSegmentation,\n  //     maskBackground\n  //   );\n\n  //   const opacity = 0.7;\n\n  //   const canvas = document.getElementById(\"canvas\");\n  //   // draw the mask onto the image on a canvas.  With opacity set to 0.7 this will darken the background.\n  //   bodyPix.drawMask(canvas, imageElement, backgroundDarkeningMask, opacity);\n  //   console.log(\"Image Masked\");\n  //   console.log(\"Estimating Part Segmentation...\");\n  //   const partSegmentation = await net.estimatePartSegmentation(\n  //     imageElement,\n  //     outputStride,\n  //     segmentationThreshold\n  //   );\n  //   console.log(\"Part Segmentation Results:\");\n  //   console.log(partSegmentation);\n  // };\n\n  const demoKickOff = async e => {\n    e.preventDefault();\n    state.net = await bodyPix.load(+guiState.input.mobileNetArchitecture);\n\n    // document.getElementById(\"loading\").style.display = \"none\";\n    document.getElementById(\"main\").style.display = \"inline-block\";\n\n    await loadVideo();\n\n    let cameras = await getVideoInputs();\n\n    setupFPS();\n    setupGui(cameras);\n\n    segmentBodyInRealTime();\n  };\n  return (\n    <div className=\"container\">\n      {/* --Container Begins-- */}\n      <h1 className=\"headerVidSeg\">Video Segmentation</h1>\n      {/* <form className=\"form\" onSubmit={e => getVid(e)}>\n        <input\n          type=\"submit\"\n          className=\"btn btn-primary\"\n          value=\"Check Devices\"\n          required\n        />\n      </form> */}\n      <div className=\"container\">\n        <form className=\"form\" onSubmit={e => demoKickOff(e)}>\n          <input\n            type=\"submit\"\n            className=\"btn btn-primary\"\n            value=\"Get Device Label\"\n            required\n          />\n        </form>\n\n        <div>\n          <form className=\"form\" onSubmit={e => startRecording(e)}>\n            <input\n              type=\"submit\"\n              className=\"btn btn-primary\"\n              value=\"Start Recording\"\n              required\n            />\n          </form>\n\n          <input\n            type=\"submit\"\n            className=\"btn btn-primary\"\n            value=\"Stop Recording\"\n            id=\"stopRec\"\n            required\n          />\n        </div>\n      </div>\n      <div id=\"stats\" />\n      <div id=\"info\" className=\"info\" />\n\n      <div id=\"main\" className=\"info\">\n        <video id=\"video\" className=\"videoClass\" playsInline />\n        <canvas id=\"output\" />\n      </div>\n\n      <video id=\"Bijli\"></video>\n      <ul id=\"colors\" className=\"info\" />\n\n      <div className=\"footer\">\n        <div className=\"footer-text\">\n          <p>\n            The BodyPix model can estimate which pixels in an image are part of\n            a person, and which pixels are part of each of 24 body parts. It\n            works on a single person, and such <strong>works best</strong> when{\" \"}\n            <strong>one person is present</strong> in an image.\n            <br />\n            <br />\n            The <strong>output stride</strong> and{\" \"}\n            <strong>model (indicated by mobileNetArchitecture)</strong> have the\n            largest effects on accuracy/speed. A <i>higher</i> output stride\n            results in lower accuracy but higher speed. A <i>larger</i> model,\n            indicated by the <i>mobileNetArchitecture</i> dropdown, results in\n            higher accuracy but lower speed.\n          </p>\n          <div className=\"footer-menu\">\n            <i className=\"material-icons switch-camera\">switch_camera</i>\n            <i className=\"material-icons mask mode active\">portrait</i>\n            <i className=\"material-icons mode bokeh\">blur_on</i>\n            <i className=\"material-icons mode part-map\">format_color_fill</i>\n            <i className=\"material-icons high-accuracy\">high_quality</i>\n          </div>\n        </div>\n      </div>\n      {/* <script src=\"videosegmentation.js\"></script> */}\n      {/* --Container Ends-- */}\n    </div>\n  );\n};\nconsole.log(\"Hello\");\n\nconsole.log(\"Bigshot\");\nexport default videosegmentation;\n\n// {/* <form className=\"form\" onSubmit={e => loadAndUseBodyPix(e)}>\n{\n  /* <h1 className=\"headerVidSeg\">Reached Video Segmentation Page</h1>\n<div id=\"divid1\">\n  <img src={img} id=\"image\" />\n</div>\n\n<br />\n<input\n  type=\"submit\"\n  className=\"btn btn-primary\"\n  value=\"Segment Image\"\n  required\n/>\n</form>\n<br />\n<canvas id=\"canvas\" width=\"100%\" />  */\n}\n"]},"metadata":{},"sourceType":"module"}
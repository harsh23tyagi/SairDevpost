{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar qs = require('querystring');\n\nvar parse = require('url').parse;\n\nvar base64id = require('base64id');\n\nvar transports = require('./transports');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Socket = require('./socket');\n\nvar util = require('util');\n\nvar debug = require('debug')('engine');\n\nvar cookieMod = require('cookie');\n/**\n * Module exports.\n */\n\n\nmodule.exports = Server;\n/**\n * Server constructor.\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Server(opts) {\n  if (!(this instanceof Server)) {\n    return new Server(opts);\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n  opts = opts || {};\n  this.wsEngine = opts.wsEngine || process.env.EIO_WS_ENGINE || 'ws';\n  this.pingTimeout = opts.pingTimeout || 5000;\n  this.pingInterval = opts.pingInterval || 25000;\n  this.upgradeTimeout = opts.upgradeTimeout || 10000;\n  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;\n  this.transports = opts.transports || Object.keys(transports);\n  this.allowUpgrades = false !== opts.allowUpgrades;\n  this.allowRequest = opts.allowRequest;\n  this.cookie = false !== opts.cookie ? opts.cookie || 'io' : false;\n  this.cookiePath = false !== opts.cookiePath ? opts.cookiePath || '/' : false;\n  this.cookieHttpOnly = false !== opts.cookieHttpOnly;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || true : false;\n  this.httpCompression = false !== opts.httpCompression ? opts.httpCompression || {} : false;\n  this.initialPacket = opts.initialPacket;\n  var self = this; // initialize compression options\n\n  ['perMessageDeflate', 'httpCompression'].forEach(function (type) {\n    var compression = self[type];\n    if (true === compression) self[type] = compression = {};\n\n    if (compression && null == compression.threshold) {\n      compression.threshold = 1024;\n    }\n  });\n  this.init();\n}\n/**\n * Protocol errors mappings.\n */\n\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4\n};\nServer.errorMessages = {\n  0: 'Transport unknown',\n  1: 'Session ID unknown',\n  2: 'Bad handshake method',\n  3: 'Bad request',\n  4: 'Forbidden'\n};\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Server, EventEmitter);\n/**\n * Initialize websocket server\n *\n * @api private\n */\n\nServer.prototype.init = function () {\n  if (!~this.transports.indexOf('websocket')) return;\n  if (this.ws) this.ws.close();\n  var wsModule;\n\n  switch (this.wsEngine) {\n    case 'uws':\n      wsModule = require('uws');\n      break;\n\n    case 'ws':\n      wsModule = require('ws');\n      break;\n\n    default:\n      throw new Error('unknown wsEngine');\n  }\n\n  this.ws = new wsModule.Server({\n    noServer: true,\n    clientTracking: false,\n    perMessageDeflate: this.perMessageDeflate,\n    maxPayload: this.maxHttpBufferSize\n  });\n};\n/**\n * Returns a list of available transports for upgrade given a certain transport.\n *\n * @return {Array}\n * @api public\n */\n\n\nServer.prototype.upgrades = function (transport) {\n  if (!this.allowUpgrades) return [];\n  return transports[transport].upgradesTo || [];\n};\n/**\n * Verifies a request.\n *\n * @param {http.IncomingMessage}\n * @return {Boolean} whether the request is valid\n * @api private\n */\n\n\nServer.prototype.verify = function (req, upgrade, fn) {\n  // transport check\n  var transport = req._query.transport;\n\n  if (!~this.transports.indexOf(transport)) {\n    debug('unknown transport \"%s\"', transport);\n    return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n  } // 'Origin' header check\n\n\n  var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n  if (isOriginInvalid) {\n    req.headers.origin = null;\n    return fn(Server.errors.BAD_REQUEST, false);\n  } // sid check\n\n\n  var sid = req._query.sid;\n\n  if (sid) {\n    if (!this.clients.hasOwnProperty(sid)) {\n      return fn(Server.errors.UNKNOWN_SID, false);\n    }\n\n    if (!upgrade && this.clients[sid].transport.name !== transport) {\n      debug('bad request: unexpected transport without upgrade');\n      return fn(Server.errors.BAD_REQUEST, false);\n    }\n  } else {\n    // handshake is GET only\n    if ('GET' !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n    if (!this.allowRequest) return fn(null, true);\n    return this.allowRequest(req, fn);\n  }\n\n  fn(null, true);\n};\n/**\n * Prepares a request by processing the query string.\n *\n * @api private\n */\n\n\nServer.prototype.prepare = function (req) {\n  // try to leverage pre-existing `req._query` (e.g: from connect)\n  if (!req._query) {\n    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};\n  }\n};\n/**\n * Closes all clients.\n *\n * @api public\n */\n\n\nServer.prototype.close = function () {\n  debug('closing all open clients');\n\n  for (var i in this.clients) {\n    if (this.clients.hasOwnProperty(i)) {\n      this.clients[i].close(true);\n    }\n  }\n\n  if (this.ws) {\n    debug('closing webSocketServer');\n    this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n  }\n\n  return this;\n};\n/**\n * Handles an Engine.IO HTTP request.\n *\n * @param {http.IncomingMessage} request\n * @param {http.ServerResponse|http.OutgoingMessage} response\n * @api public\n */\n\n\nServer.prototype.handleRequest = function (req, res) {\n  debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n  this.prepare(req);\n  req.res = res;\n  var self = this;\n  this.verify(req, false, function (err, success) {\n    if (!success) {\n      sendErrorMessage(req, res, err);\n      return;\n    }\n\n    if (req._query.sid) {\n      debug('setting new request for existing client');\n\n      self.clients[req._query.sid].transport.onRequest(req);\n    } else {\n      self.handshake(req._query.transport, req);\n    }\n  });\n};\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\n\nfunction sendErrorMessage(req, res, code) {\n  var headers = {\n    'Content-Type': 'application/json'\n  };\n  var isForbidden = !Server.errorMessages.hasOwnProperty(code);\n\n  if (isForbidden) {\n    res.writeHead(403, headers);\n    res.end(JSON.stringify({\n      code: Server.errors.FORBIDDEN,\n      message: code || Server.errorMessages[Server.errors.FORBIDDEN]\n    }));\n    return;\n  }\n\n  if (req.headers.origin) {\n    headers['Access-Control-Allow-Credentials'] = 'true';\n    headers['Access-Control-Allow-Origin'] = req.headers.origin;\n  } else {\n    headers['Access-Control-Allow-Origin'] = '*';\n  }\n\n  if (res !== undefined) {\n    res.writeHead(400, headers);\n    res.end(JSON.stringify({\n      code: code,\n      message: Server.errorMessages[code]\n    }));\n  }\n}\n/**\n * generate a socket id.\n * Overwrite this method to generate your custom socket id\n *\n * @param {Object} request object\n * @api public\n */\n\n\nServer.prototype.generateId = function (req) {\n  return base64id.generateId();\n};\n/**\n * Handshakes a new client.\n *\n * @param {String} transport name\n * @param {Object} request object\n * @api private\n */\n\n\nServer.prototype.handshake = function (transportName, req) {\n  var id = this.generateId(req);\n  debug('handshaking client \"%s\"', id);\n\n  try {\n    var transport = new transports[transportName](req);\n\n    if ('polling' === transportName) {\n      transport.maxHttpBufferSize = this.maxHttpBufferSize;\n      transport.httpCompression = this.httpCompression;\n    } else if ('websocket' === transportName) {\n      transport.perMessageDeflate = this.perMessageDeflate;\n    }\n\n    if (req._query && req._query.b64) {\n      transport.supportsBinary = false;\n    } else {\n      transport.supportsBinary = true;\n    }\n  } catch (e) {\n    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n    return;\n  }\n\n  var socket = new Socket(id, this, transport, req);\n  var self = this;\n\n  if (false !== this.cookie) {\n    transport.on('headers', function (headers) {\n      headers['Set-Cookie'] = cookieMod.serialize(self.cookie, id, {\n        path: self.cookiePath,\n        httpOnly: self.cookiePath ? self.cookieHttpOnly : false\n      });\n    });\n  }\n\n  transport.onRequest(req);\n  this.clients[id] = socket;\n  this.clientsCount++;\n  socket.once('close', function () {\n    delete self.clients[id];\n    self.clientsCount--;\n  });\n  this.emit('connection', socket);\n};\n/**\n * Handles an Engine.IO HTTP Upgrade.\n *\n * @api public\n */\n\n\nServer.prototype.handleUpgrade = function (req, socket, upgradeHead) {\n  this.prepare(req);\n  var self = this;\n  this.verify(req, true, function (err, success) {\n    if (!success) {\n      abortConnection(socket, err);\n      return;\n    }\n\n    var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n    upgradeHead = null; // delegate to ws\n\n    self.ws.handleUpgrade(req, socket, head, function (conn) {\n      self.onWebSocket(req, conn);\n    });\n  });\n};\n/**\n * Called upon a ws.io connection.\n *\n * @param {ws.Socket} websocket\n * @api private\n */\n\n\nServer.prototype.onWebSocket = function (req, socket) {\n  socket.on('error', onUpgradeError);\n\n  if (transports[req._query.transport] !== undefined && !transports[req._query.transport].prototype.handlesUpgrades) {\n    debug('transport doesnt handle upgraded requests');\n    socket.close();\n    return;\n  } // get client id\n\n\n  var id = req._query.sid; // keep a reference to the ws.Socket\n\n  req.websocket = socket;\n\n  if (id) {\n    var client = this.clients[id];\n\n    if (!client) {\n      debug('upgrade attempt for closed client');\n      socket.close();\n    } else if (client.upgrading) {\n      debug('transport has already been trying to upgrade');\n      socket.close();\n    } else if (client.upgraded) {\n      debug('transport had already been upgraded');\n      socket.close();\n    } else {\n      debug('upgrading existing transport'); // transport error handling takes over\n\n      socket.removeListener('error', onUpgradeError);\n      var transport = new transports[req._query.transport](req);\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n\n      transport.perMessageDeflate = this.perMessageDeflate;\n      client.maybeUpgrade(transport);\n    }\n  } else {\n    // transport error handling takes over\n    socket.removeListener('error', onUpgradeError);\n    this.handshake(req._query.transport, req);\n  }\n\n  function onUpgradeError() {\n    debug('websocket error before upgrade'); // socket.close() not needed\n  }\n};\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @api public\n */\n\n\nServer.prototype.attach = function (server, options) {\n  var self = this;\n  options = options || {};\n  var path = (options.path || '/engine.io').replace(/\\/$/, '');\n  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n  path += '/';\n\n  function check(req) {\n    if ('OPTIONS' === req.method && false === options.handlePreflightRequest) {\n      return false;\n    }\n\n    return path === req.url.substr(0, path.length);\n  } // cache and clean up listeners\n\n\n  var listeners = server.listeners('request').slice(0);\n  server.removeAllListeners('request');\n  server.on('close', self.close.bind(self));\n  server.on('listening', self.init.bind(self)); // add request handler\n\n  server.on('request', function (req, res) {\n    if (check(req)) {\n      debug('intercepting request for path \"%s\"', path);\n\n      if ('OPTIONS' === req.method && 'function' === typeof options.handlePreflightRequest) {\n        options.handlePreflightRequest.call(server, req, res);\n      } else {\n        self.handleRequest(req, res);\n      }\n    } else {\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].call(server, req, res);\n      }\n    }\n  });\n\n  if (~self.transports.indexOf('websocket')) {\n    server.on('upgrade', function (req, socket, head) {\n      if (check(req)) {\n        self.handleUpgrade(req, socket, head);\n      } else if (false !== options.destroyUpgrade) {\n        // default node behavior is to disconnect when no handlers\n        // but by adding a handler, we prevent that\n        // and if no eio thing handles the upgrade\n        // then the socket needs to die!\n        setTimeout(function () {\n          if (socket.writable && socket.bytesWritten <= 0) {\n            return socket.end();\n          }\n        }, destroyUpgradeTimeout);\n      }\n    });\n  }\n};\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\n\nfunction abortConnection(socket, code) {\n  if (socket.writable) {\n    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : String(code || '');\n    var length = Buffer.byteLength(message);\n    socket.write('HTTP/1.1 400 Bad Request\\r\\n' + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: ' + length + '\\r\\n' + '\\r\\n' + message);\n  }\n\n  socket.destroy();\n}\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n\n\nvar validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += '';\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) return true;\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) return true;\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) return true;\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) return true;\n\n  for (var i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) return true;\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}
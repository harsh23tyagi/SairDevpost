{"ast":null,"code":"/**\n * Module requirements.\n */\nvar Transport = require('../transport');\n\nvar parser = require('engine.io-parser');\n\nvar zlib = require('zlib');\n\nvar accepts = require('accepts');\n\nvar util = require('util');\n\nvar debug = require('debug')('engine:polling');\n\nvar compressionMethods = {\n  gzip: zlib.createGzip,\n  deflate: zlib.createDeflate\n};\n/**\n * Exports the constructor.\n */\n\nmodule.exports = Polling;\n/**\n * HTTP polling constructor.\n *\n * @api public.\n */\n\nfunction Polling(req) {\n  Transport.call(this, req);\n  this.closeTimeout = 30 * 1000;\n  this.maxHttpBufferSize = null;\n  this.httpCompression = null;\n}\n/**\n * Inherits from Transport.\n *\n * @api public.\n */\n\n\nutil.inherits(Polling, Transport);\n/**\n * Transport name\n *\n * @api public\n */\n\nPolling.prototype.name = 'polling';\n/**\n * Overrides onRequest.\n *\n * @param {http.IncomingMessage}\n * @api private\n */\n\nPolling.prototype.onRequest = function (req) {\n  var res = req.res;\n\n  if ('GET' === req.method) {\n    this.onPollRequest(req, res);\n  } else if ('POST' === req.method) {\n    this.onDataRequest(req, res);\n  } else {\n    res.writeHead(500);\n    res.end();\n  }\n};\n/**\n * The client sends a request awaiting for us to send data.\n *\n * @api private\n */\n\n\nPolling.prototype.onPollRequest = function (req, res) {\n  if (this.req) {\n    debug('request overlap'); // assert: this.res, '.req and .res should be (un)set together'\n\n    this.onError('overlap from client');\n    res.writeHead(500);\n    res.end();\n    return;\n  }\n\n  debug('setting request');\n  this.req = req;\n  this.res = res;\n  var self = this;\n\n  function onClose() {\n    self.onError('poll connection closed prematurely');\n  }\n\n  function cleanup() {\n    req.removeListener('close', onClose);\n    self.req = self.res = null;\n  }\n\n  req.cleanup = cleanup;\n  req.on('close', onClose);\n  this.writable = true;\n  this.emit('drain'); // if we're still writable but had a pending close, trigger an empty send\n\n  if (this.writable && this.shouldClose) {\n    debug('triggering empty send to append close packet');\n    this.send([{\n      type: 'noop'\n    }]);\n  }\n};\n/**\n * The client sends a request with data.\n *\n * @api private\n */\n\n\nPolling.prototype.onDataRequest = function (req, res) {\n  if (this.dataReq) {\n    // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n    this.onError('data request overlap from client');\n    res.writeHead(500);\n    res.end();\n    return;\n  }\n\n  var isBinary = 'application/octet-stream' === req.headers['content-type'];\n  this.dataReq = req;\n  this.dataRes = res;\n  var chunks = isBinary ? Buffer.concat([]) : '';\n  var self = this;\n\n  function cleanup() {\n    req.removeListener('data', onData);\n    req.removeListener('end', onEnd);\n    req.removeListener('close', onClose);\n    self.dataReq = self.dataRes = chunks = null;\n  }\n\n  function onClose() {\n    cleanup();\n    self.onError('data request connection closed prematurely');\n  }\n\n  function onData(data) {\n    var contentLength;\n\n    if (isBinary) {\n      chunks = Buffer.concat([chunks, data]);\n      contentLength = chunks.length;\n    } else {\n      chunks += data;\n      contentLength = Buffer.byteLength(chunks);\n    }\n\n    if (contentLength > self.maxHttpBufferSize) {\n      chunks = isBinary ? Buffer.concat([]) : '';\n      req.connection.destroy();\n    }\n  }\n\n  function onEnd() {\n    self.onData(chunks);\n    var headers = {\n      // text/html is required instead of text/plain to avoid an\n      // unwanted download dialog on certain user-agents (GH-43)\n      'Content-Type': 'text/html',\n      'Content-Length': 2\n    };\n    res.writeHead(200, self.headers(req, headers));\n    res.end('ok');\n    cleanup();\n  }\n\n  req.on('close', onClose);\n  if (!isBinary) req.setEncoding('utf8');\n  req.on('data', onData);\n  req.on('end', onEnd);\n};\n/**\n * Processes the incoming data payload.\n *\n * @param {String} encoded payload\n * @api private\n */\n\n\nPolling.prototype.onData = function (data) {\n  debug('received \"%s\"', data);\n  var self = this;\n\n  var callback = function (packet) {\n    if ('close' === packet.type) {\n      debug('got xhr close packet');\n      self.onClose();\n      return false;\n    }\n\n    self.onPacket(packet);\n  };\n\n  parser.decodePayload(data, callback);\n};\n/**\n * Overrides onClose.\n *\n * @api private\n */\n\n\nPolling.prototype.onClose = function () {\n  if (this.writable) {\n    // close pending poll request\n    this.send([{\n      type: 'noop'\n    }]);\n  }\n\n  Transport.prototype.onClose.call(this);\n};\n/**\n * Writes a packet payload.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nPolling.prototype.send = function (packets) {\n  this.writable = false;\n\n  if (this.shouldClose) {\n    debug('appending close packet to payload');\n    packets.push({\n      type: 'close'\n    });\n    this.shouldClose();\n    this.shouldClose = null;\n  }\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    var compress = packets.some(function (packet) {\n      return packet.options && packet.options.compress;\n    });\n    self.write(data, {\n      compress: compress\n    });\n  });\n};\n/**\n * Writes data as response to poll request.\n *\n * @param {String} data\n * @param {Object} options\n * @api private\n */\n\n\nPolling.prototype.write = function (data, options) {\n  debug('writing \"%s\"', data);\n  var self = this;\n  this.doWrite(data, options, function () {\n    self.req.cleanup();\n  });\n};\n/**\n * Performs the write.\n *\n * @api private\n */\n\n\nPolling.prototype.doWrite = function (data, options, callback) {\n  var self = this; // explicit UTF-8 is required for pages not served under utf\n\n  var isString = typeof data === 'string';\n  var contentType = isString ? 'text/plain; charset=UTF-8' : 'application/octet-stream';\n  var headers = {\n    'Content-Type': contentType\n  };\n\n  if (!this.httpCompression || !options.compress) {\n    respond(data);\n    return;\n  }\n\n  var len = isString ? Buffer.byteLength(data) : data.length;\n\n  if (len < this.httpCompression.threshold) {\n    respond(data);\n    return;\n  }\n\n  var encoding = accepts(this.req).encodings(['gzip', 'deflate']);\n\n  if (!encoding) {\n    respond(data);\n    return;\n  }\n\n  this.compress(data, encoding, function (err, data) {\n    if (err) {\n      self.res.writeHead(500);\n      self.res.end();\n      callback(err);\n      return;\n    }\n\n    headers['Content-Encoding'] = encoding;\n    respond(data);\n  });\n\n  function respond(data) {\n    headers['Content-Length'] = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\n    self.res.writeHead(200, self.headers(self.req, headers));\n    self.res.end(data);\n    callback();\n  }\n};\n/**\n * Compresses data.\n *\n * @api private\n */\n\n\nPolling.prototype.compress = function (data, encoding, callback) {\n  debug('compressing');\n  var buffers = [];\n  var nread = 0;\n  compressionMethods[encoding](this.httpCompression).on('error', callback).on('data', function (chunk) {\n    buffers.push(chunk);\n    nread += chunk.length;\n  }).on('end', function () {\n    callback(null, Buffer.concat(buffers, nread));\n  }).end(data);\n};\n/**\n * Closes the transport.\n *\n * @api private\n */\n\n\nPolling.prototype.doClose = function (fn) {\n  debug('closing');\n  var self = this;\n  var closeTimeoutTimer;\n\n  if (this.dataReq) {\n    debug('aborting ongoing data request');\n    this.dataReq.destroy();\n  }\n\n  if (this.writable) {\n    debug('transport writable - closing right away');\n    this.send([{\n      type: 'close'\n    }]);\n    onClose();\n  } else if (this.discarded) {\n    debug('transport discarded - closing right away');\n    onClose();\n  } else {\n    debug('transport not writable - buffering orderly close');\n    this.shouldClose = onClose;\n    closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n  }\n\n  function onClose() {\n    clearTimeout(closeTimeoutTimer);\n    fn();\n    self.onClose();\n  }\n};\n/**\n * Returns headers for a response.\n *\n * @param {http.IncomingMessage} request\n * @param {Object} extra headers\n * @api private\n */\n\n\nPolling.prototype.headers = function (req, headers) {\n  headers = headers || {}; // prevent XSS warnings on IE\n  // https://github.com/LearnBoost/socket.io/pull/1333\n\n  var ua = req.headers['user-agent'];\n\n  if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {\n    headers['X-XSS-Protection'] = '0';\n  }\n\n  this.emit('headers', headers);\n  return headers;\n};","map":null,"metadata":{},"sourceType":"script"}